<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>ZeroNote</title>
    <link rel="icon" href="favicon.avif" type="image/avif">
    <meta name="description" content="A simple note-taking app with text, maths and drawing capabilities.">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.9.1/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    <meta property="og:title" content="ZeroNote">
    <meta property="og:description" content="A simple note-taking app with text, maths and drawing capabilities.">
    <meta property="og:image"
        content="https://raw.githubusercontent.com/Nikityyy/nikityyy.github.io/refs/heads/main/ZeroNote/favicon.png">
    <meta property="og:url" content="https://nikityyy.github.io/ZeroNote/">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ZeroNote">
    <meta name="twitter:description" content="A simple note-taking app with text, maths and drawing capabilities.">
    <meta name="twitter:image"
        content="https://raw.githubusercontent.com/Nikityyy/nikityyy.github.io/refs/heads/main/ZeroNote/favicon.png">
    <meta name="twitter:url" content="https://nikityyy.github.io/ZeroNote/">
    <meta name="twitter:site" content="@itsnikity">
    <meta name="twitter:creator" content="@itsnikity">
    <style>
        :root {
            --sidebar-width: 250px;
            --sidebar-bg: #1a1a1a;
            --main-bg: #000000;
            --text-color: #ffffff;
            --button-bg: #333333;
            --button-hover: #444444;
            --border-color: #333333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--main-bg);
            color: var(--text-color);
            overflow: hidden;
            height: 100vh;
        }

        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: var(--sidebar-width);
            height: 100vh;
            background: var(--sidebar-bg);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-toggle {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: var(--button-bg);
            border: none;
            color: var(--text-color);
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease;
            z-index: 1001;
        }

        .sidebar-toggle.open {
            transform: translateX(var(--sidebar-width));
        }

        .notes-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .note-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--button-bg);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
        }

        .note-item:hover {
            background: var(--button-hover);
        }

        .note-title {
            font-weight: 500;
            margin-bottom: 0.25rem;
            outline: none;
            cursor: text;
            display: inline-block;
        }

        .note-date {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .note-delete {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            opacity: 0.7;
        }

        .note-delete:hover {
            opacity: 1;
        }

        .new-note {
            margin: 1rem;
            padding: 0.75rem;
            background: var(--button-bg);
            border: none;
            color: var(--text-color);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
        }

        .new-note:hover {
            background: var(--button-hover);
        }

        .main-content {
            position: relative;
            height: 100vh;
            margin-left: 0;
            transition: margin-left 0.3s ease;
        }

        .main-content.sidebar-open {
            margin-left: var(--sidebar-width);
        }

        .top-buttons {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1001;
            display: flex;
            gap: 0.5rem;
        }

        .mode-button {
            background: var(--button-bg);
            border: none;
            color: var(--text-color);
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
        }

        .mode-button::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 2px;
            background: #4a9eff;
            transition: width 0.2s ease;
        }

        .mode-button:hover {
            background: var(--button-hover);
        }

        .mode-button.active {
            background: var(--button-hover);
            opacity: 1;
            box-shadow: 0 0 8px rgba(74, 158, 255, 0.3);
        }

        .mode-button.active::after {
            width: 80%;
        }

        .mode-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            box-shadow: none;
        }

        .mode-button:disabled::after {
            width: 0;
        }

        .canvas-container {
            touch-action: none;
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
        }

        .background-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        .text-fields-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .text-fields-layer>* {
            pointer-events: auto;
        }

        .text-field {
            position: absolute;
            background: rgba(40, 40, 40, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
            cursor: move;
            touch-action: none;
            width: max-content;
            max-width: 500px;
            white-space: pre-wrap;
            word-break: break-word;
            z-index: 3;
            font-family: "Patrick Hand", sans-serif;
            font-size: 2rem;
            user-select: text;
        }

        .math-field {
            max-width: max-content;
        }

        .text-field * {
            user-select: text;
        }

        .mq-editable-field {
            border-radius: 4px;
            cursor: text;
            font-family: "Patrick Hand", sans-serif;
        }

        .mq-math-mode {
            font-family: 'Times New Roman', Times, serif;
        }

        .mq-cursor {
            background: white !important;
            border-color: white !important;
        }

        .mq-root-block {
            padding: 2px 5px !important;
        }

        .mq-focused {
            box-shadow: 0 0 0 2px #4a9eff;
            background: rgba(74, 158, 255, 0.1);
        }

        .text-field.selected {
            border-color: #4a9eff;
        }

        .selection-box {
            position: absolute;
            border: 1px dashed #4a9eff;
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 2;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.open {
            display: flex;
        }

        .modal-content {
            background: var(--sidebar-bg);
            padding: 2rem;
            border-radius: 8px;
            text-align: center;
        }

        .modal-buttons {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .modal-button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: var(--button-bg);
            color: var(--text-color);
        }

        .modal-button:hover {
            background: var(--button-hover);
        }

        .modal-button.delete {
            background: #ff4444;
        }

        .modal-button.delete:hover {
            background: #ff6666;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--main-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--button-bg);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--button-hover);
        }

        .image-field {
            position: absolute;
            cursor: move;
            touch-action: none;
            z-index: 3;
        }

        .image-field img {
            display: block;
            height: auto;
            pointer-events: none;
            border-radius: 5px;
        }

        .image-field.selected {
            outline: 2px solid #4a9eff;
        }

        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #4a9eff;
            border-radius: 50%;
            display: none;
        }

        .image-field.selected .resize-handle {
            display: block;
        }

        .resize-handle.top-left {
            top: -5px;
            left: -5px;
            cursor: nw-resize;
        }

        .resize-handle.top-right {
            top: -5px;
            right: -5px;
            cursor: ne-resize;
        }

        .resize-handle.bottom-left {
            bottom: -5px;
            left: -5px;
            cursor: sw-resize;
        }

        .resize-handle.bottom-right {
            bottom: -5px;
            right: -5px;
            cursor: se-resize;
        }

        .resize-handle.left {
            left: -5px;
            top: 50%;
            transform: translateY(-50%);
            cursor: w-resize;
        }

        .resize-handle.right {
            right: -5px;
            top: 50%;
            transform: translateY(-50%);
            cursor: e-resize;
        }

        .resize-handle.top {
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            cursor: n-resize;
        }

        .resize-handle.bottom {
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            cursor: s-resize;
        }

        .context-menu {
            position: absolute;
            background: var(--sidebar-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem 0;
            z-index: 10000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .context-menu-item {
            padding: 0.5rem 1rem;
            color: var(--text-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
        }

        .context-menu-item:hover {
            background: var(--button-hover);
        }

        .context-menu-item svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .graph-field {
            position: absolute;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            cursor: move;
            touch-action: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .graph-field.selected {
            outline: 2px solid #4a9eff;
        }

        [contenteditable=true]:empty:before {
            content: attr(data-ph);
            color: grey;
            font-style: italic;
            pointer-events: none;
        }

        .text-field:not(.math-field) {
            width: max-content;
            position: absolute;
        }

        .text-field:not(.math-field) .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #4a9eff;
            border-radius: 50%;
            display: none;
            pointer-events: auto;
            overflow: visible;
        }

        .text-field:not(.math-field).selected .resize-handle {
            display: block;
        }

        .text-field:not(.math-field) .resize-handle.left {
            left: -5px;
            top: 50%;
            transform: translateY(-50%);
            cursor: w-resize;
            z-index: 100;
        }

        .text-field:not(.math-field) .resize-handle.right {
            right: -5px;
            top: 50%;
            transform: translateY(-50%);
            cursor: e-resize;
            z-index: 100;
        }

        .text-field:not(.math-field) .resize-handle.top {
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            cursor: n-resize;
        }

        .text-field:not(.math-field) .resize-handle.bottom {
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            cursor: s-resize;
        }

        .text-field:not(.math-field) {
            position: absolute;
            height: fit-content;
            cursor: move;
        }

        .note-item {
            box-shadow: -4px 0 0 0 transparent;
            transition: box-shadow 0.3s ease;
        }

        .note-item.active-note {
            box-shadow: -4px 0 0 0 #4a9eff;
            animation: slideIn 0.4s ease;
        }

        @keyframes slideIn {
            from {
                box-shadow: -4px 0 0 0 transparent;
            }

            to {
                box-shadow: -4px 0 0 0 #4a9eff;
            }
        }

        @media screen and (max-width: 420px) {
            .sidebar.open~.main-content .top-buttons {
                flex-direction: column;
            }
        }

        @media screen and (max-width: 370px) {
            .sidebar.open~.main-content .top-buttons {
                top: calc(1rem + 40px + 0.5rem);
            }
        }

        @media screen and (max-width: 322px) {
            .sidebar.open~.main-content .top-buttons {
                position: absolute;
                top: calc(1rem + 40px + 0.5rem);
                left: 1rem;
                width: 40px;
            }
        }

        @media screen and (max-width: 310px) {
            .sidebar.open {
                width: 175px;
            }

            .sidebar-toggle.open {
                transform: translateX(175px);
            }

            .sidebar.open~.main-content {
                margin-left: 175px;
            }

            .sidebar.open~.main-content .top-buttons {
                position: absolute;
                top: calc(1rem + 40px + 0.5rem);
                left: 1rem;
            }
        }

        @media screen and (max-width: 167px) {
            .top-buttons {
                flex-direction: column;
            }
        }

        @media screen and (max-width: 120px) {
            .top-buttons {
                position: absolute;
                top: calc(1rem + 40px + 0.5rem);
                left: 1rem;
                width: 40px;
            }
        }
    </style>
</head>

<body oncontextmenu="return false">
    <button class="sidebar-toggle">
        <span class="material-icons">menu</span>
    </button>

    <div class="sidebar">
        <div class="sidebar-header">
            <h2>ZeroNote</h2>
        </div>
        <button class="new-note">
            <span class="material-icons">add</span>
            New Note
        </button>
        <div class="notes-list"></div>
    </div>

    <div class="main-content">
        <div class="top-buttons">
            <button class="mode-button math-mode" title="Math Mode">
                <span class="material-icons">functions</span>
            </button>
            <button class="mode-button drawing-mode" title="Drawing Mode">
                <span class="material-icons">brush</span>
            </button>
        </div>
        <div class="canvas-container">
            <canvas class="background-canvas"></canvas>
            <div class="text-fields-layer"></div>
        </div>
    </div>

    <div class="modal" id="deleteModal">
        <div class="modal-content">
            <p>Are you sure you want to delete this note?</p>
            <div class="modal-buttons">
                <button class="modal-button cancel">Cancel</button>
                <button class="modal-button delete">Delete</button>
            </div>
        </div>
    </div>

    <script>
        const MQ = MathQuill.getInterface(2);

        class Note {
            static lastId = 0;

            constructor(id = null, title = null) {
                this.id = id !== null ? Number(id) : ++Note.lastId;
                this.title = title || `Note ${this.id}`;
                this.textFields = [];
                this.drawings = [];
                this.imageFields = [];
                this.scale = 1;
                this.lastEdited = Date.now();
            }
        }

        class TextField {
            constructor(x, y, content = '', isMath = false, id = null, width = null) {
                this.id = id ?? crypto.randomUUID();
                this.x = x;
                this.y = y;
                this.content = content;
                this.isMath = isMath;
                this.mathField = null;
                this.width = width;
            }

            toJSON() {
                return {
                    id: this.id,
                    x: this.x,
                    y: this.y,
                    content: this.content,
                    isMath: this.isMath,
                    width: this.width
                };
            }
        }

        class ImageField {
            constructor(x, y, dataUrl, width, height) {
                this.id = crypto.randomUUID();
                this.x = x;
                this.y = y;
                this.dataUrl = dataUrl;
                this.width = width;
                this.height = height;
            }
        }

        class GraphField {
            constructor(x, y, fieldId, data, layout, config) {
                this.id = crypto.randomUUID();
                this.x = x;
                this.y = y;
                this.width = layout.width || 600;
                this.height = layout.height || 400;
                this.fieldId = fieldId;
                this.data = data;
                this.layout = layout;
                this.config = config;
            }
        }

        class ZeroNote {
            constructor() {
                this.minScale = 0.3;
                this.maxScale = 3;
                this.scale = 1;
                this.lastPinchDistance = 0;

                this.notes = [];
                this.currentNote = null;
                this.activeMode = 'text';
                this.mathModeActive = false;
                this.scale = 1;
                this.selectedFields = new Set();
                this.selectedDrawings = new Set();
                this.isDrawing = false;
                this.undoStack = [];
                this.redoStack = [];
                this.canvasOffset = { x: 0, y: 0 };
                this.isPanning = false;
                this.lastPanPosition = { x: 0, y: 0 };
                this.isDraggingDrawing = false;
                this.dragStartPositions = new Map();
                this.deleteButton = null;
                this.justCreatedTextField = false;
                this.isStylusDrawing = false;

                this.setupDOM();
                this.setupEventListeners();
                this.loadNotes();
                this.setupInteract();
                this.setupDrawing();
                this.setupImageHandlers();
                this.setupZoom();
            }

            drawDotPattern() {
                const gridSize = 50;
                const dotRadius = 1;
                const ctx = this.ctx;

                const rect = this.canvasContainer.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;

                const startX = (-this.canvasOffset.x) / this.scale;
                const startY = (-this.canvasOffset.y) / this.scale;
                const endX = (width - this.canvasOffset.x) / this.scale;
                const endY = (height - this.canvasOffset.y) / this.scale;

                const gridStartX = Math.floor(startX / gridSize) * gridSize;
                const gridStartY = Math.floor(startY / gridSize) * gridSize;
                const gridEndX = Math.ceil(endX / gridSize) * gridSize;
                const gridEndY = Math.ceil(endY / gridSize) * gridSize;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';

                for (let x = gridStartX; x <= gridEndX; x += gridSize) {
                    for (let y = gridStartY; y <= gridEndY; y += gridSize) {
                        ctx.beginPath();
                        ctx.arc(x, y, dotRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            setupZoom() {
                this.canvasContainer.addEventListener('wheel', (e) => {
                    e.preventDefault();

                    const rect = this.canvasContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    const canvasX = (mouseX - this.canvasOffset.x) / this.scale;
                    const canvasY = (mouseY - this.canvasOffset.y) / this.scale;

                    const delta = e.deltaY < 0 ? 1.1 : 0.9;
                    const newScale = Math.min(Math.max(this.scale * delta, this.minScale), this.maxScale);

                    const scaleDiff = newScale - this.scale;
                    this.canvasOffset.x -= canvasX * scaleDiff;
                    this.canvasOffset.y -= canvasY * scaleDiff;

                    this.scale = newScale;
                    this.updateCanvasTransform();
                }, { passive: false });

                this.canvasContainer.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        this.lastPinchDistance = Math.hypot(
                            touch1.clientX - touch2.clientX,
                            touch1.clientY - touch2.clientY
                        );
                    }
                }, { passive: false });

                this.canvasContainer.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.hypot(
                            touch1.clientX - touch2.clientX,
                            touch1.clientY - touch2.clientY
                        );

                        if (this.lastPinchDistance > 0) {
                            const rect = this.canvasContainer.getBoundingClientRect();
                            const centerX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
                            const centerY = (touch1.clientY + touch2.clientY) / 2 - rect.top;

                            const canvasX = (centerX - this.canvasOffset.x) / this.scale;
                            const canvasY = (centerY - this.canvasOffset.y) / this.scale;

                            const delta = currentDistance / this.lastPinchDistance;
                            const newScale = Math.min(Math.max(this.scale * delta, this.minScale), this.maxScale);

                            const scaleDiff = newScale - this.scale;
                            this.canvasOffset.x -= canvasX * scaleDiff;
                            this.canvasOffset.y -= canvasY * scaleDiff;

                            this.scale = newScale;
                            this.updateCanvasTransform();
                        }

                        this.lastPinchDistance = currentDistance;
                    }
                }, { passive: false });

                this.canvasContainer.addEventListener('touchend', () => {
                    this.lastPinchDistance = 0;
                });
            }

            setupDOM() {
                this.sidebar = document.querySelector('.sidebar');
                this.sidebarToggle = document.querySelector('.sidebar-toggle');
                this.notesList = document.querySelector('.notes-list');
                this.newNoteButton = document.querySelector('.new-note');
                this.mainContent = document.querySelector('.main-content');
                this.mathModeButton = document.querySelector('.math-mode');
                this.drawingModeButton = document.querySelector('.drawing-mode');
                this.textFieldsLayer = document.querySelector('.text-fields-layer');
                this.backgroundCanvas = document.querySelector('.background-canvas');
                this.deleteModal = document.querySelector('#deleteModal');
                this.canvasContainer = document.querySelector('.canvas-container');

                this.ctx = this.backgroundCanvas.getContext('2d');
                this.resizeCanvas();
                this.mathModeButton.disabled = false;
                this.mathModeButton.style.opacity = '1';

                this.canvasContainer.innerHTML = '';
                this.canvasContainer.appendChild(this.backgroundCanvas);
                this.canvasContainer.appendChild(this.textFieldsLayer);

                this.backgroundCanvas.style.transform = 'none';
                this.textFieldsLayer.style.transform = 'none';

                const sidebarState = localStorage.getItem('zeronote-sidebarState');
                if (!sidebarState || sidebarState === 'open') {
                    localStorage.setItem('zeronote-sidebarState', 'open');
                    this.sidebar.classList.add('open');
                    this.sidebarToggle.classList.add('open');
                    this.mainContent.classList.add('sidebar-open');
                }
                this.drawingModeButton.classList.remove('active');
                this.canvasContainer.style.cursor = 'grab';
                this.setupZoom();
            }

            showContextMenu(x, y, fieldElement) {
                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.style.left = `${x}px`;
                menu.style.top = `${y}px`;

                const visualizeItem = document.createElement('div');
                visualizeItem.className = 'context-menu-item';
                visualizeItem.innerHTML = `
                    <span class="material-icons">insert_chart</span>
                    Visualize
                `;
                visualizeItem.onclick = () => this.visualizeFunction(fieldElement);
                menu.appendChild(visualizeItem);

                const derivativeItem = document.createElement('div');
                derivativeItem.className = 'context-menu-item';
                derivativeItem.innerHTML = `
                    <span class="material-icons">calculate</span>
                    Derivative
                `;
                derivativeItem.onclick = () => this.calculateDerivative(fieldElement);
                menu.appendChild(derivativeItem);

                document.body.appendChild(menu);

                setTimeout(() => {
                    const listener = () => {
                        menu.remove();
                        document.removeEventListener('click', listener);
                    };
                    document.addEventListener('click', listener);
                });
            }

            latexToMathJS(latex) {
                const parts = latex.split('=');
                let expression = parts.length > 1 ? parts[1] : parts[0];

                return this.cleanLatexForMathJS(expression);
            }

            cleanLatexForMathJS(latex) {
                return latex
                    .replace(/\\,/g, '')
                    .replace(/\\cdot/g, '*')
                    .replace(/\\times/g, '*')
                    .replace(/\\frac\{(.*?)\}\{(.*?)\}/g, '($1)/($2)')
                    .replace(/\^\{?(.*?)\}?/g, '^$1')
                    .replace(/\\sqrt\{(.*?)\}/g, 'sqrt($1)')
                    .replace(/([a-zA-Z])(?=[a-zA-Z\d])/g, '$1*')
                    .replace(/(\d)(?=[a-zA-Z])/g, '$1*')
                    .replace(/\\ln/g, 'log')
                    .replace(/\\sin/g, 'sin')
                    .replace(/\\cos/g, 'cos')
                    .replace(/\\tan/g, 'tan')
                    .replace(/\\pi/g, 'pi')
                    .replace(/\\/g, '')
                    .replace(/\{|\}/g, '')
                    .trim();
            }

            async visualizeFunction(fieldElement) {
                const fieldId = fieldElement.dataset.id;
                const textField = this.currentNote.textFields.find(f => f.id === fieldId);
                if (!textField) return;

                try {
                    const mathJSExpression = this.latexToMathJS(textField.content);
                    const expr = math.parse(mathJSExpression);
                    const xValues = Array.from({ length: 100 }, (_, i) => -10 + i * 0.2);
                    const yValues = xValues.map(x => expr.evaluate({ x }));

                    const trace = { x: xValues, y: yValues, mode: 'lines', name: 'f(x)' };
                    const layout = { width: 600, height: 400, margin: { t: 20, b: 20, l: 40, r: 20 } };

                    const imageUrl = await Plotly.toImage({ data: [trace], layout: layout }, { format: 'png' });

                    const img = new Image();
                    await new Promise((resolve) => {
                        img.onload = resolve;
                        img.src = imageUrl;
                    });

                    const imageField = new ImageField(
                        textField.x + 50,
                        textField.y,
                        imageUrl,
                        img.width * 0.5,
                        img.height * 0.5
                    );

                    this.currentNote.imageFields.push(imageField);
                    this.createImageField(imageField);
                    this.saveNotes();

                } catch (error) {
                    alert(`Error visualizing function: ${error.message}`);
                }
            }

            setupGraphInteractions(graphDiv) {
                interact(graphDiv)
                    .draggable({
                        listeners: {
                            start: () => graphDiv.classList.add('selected'),
                            move: (e) => {
                                const x = parseFloat(graphDiv.dataset.x || 0) + e.dx;
                                const y = parseFloat(graphDiv.dataset.y || 0) + e.dy;
                                graphDiv.style.transform = `translate(${x}px, ${y}px)`;
                                graphDiv.dataset.x = x;
                                graphDiv.dataset.y = y;
                            }
                        }
                    })
                    .resizable({
                        edges: { left: true, right: true, bottom: true, top: true },
                        listeners: {
                            move: (e) => {
                                graphDiv.style.width = `${e.rect.width}px`;
                                graphDiv.style.height = `${e.rect.height}px`;
                                Plotly.relayout(graphDiv, { width: e.rect.width, height: e.rect.height });
                            }
                        }
                    });
            }

            getFunctionName(latex) {
                const match = latex.match(/^\s*([a-zA-Z]+'*)\\left\(\s*([a-zA-Z])\s*\\right\)/);
                return match ? {
                    name: match[1],
                    variable: match[2]
                } : { name: 'f', variable: 'x' };
            }

            calculateDerivative(fieldElement) {
                const fieldId = fieldElement.dataset.id;
                const textField = this.currentNote.textFields.find(f => f.id === fieldId);
                if (!textField) return;

                try {
                    const originalLatex = textField.content;
                    const { name: funcName, variable } = this.getFunctionName(originalLatex);
                    const mathJSExpression = this.latexToMathJS(originalLatex);
                    const expr = math.parse(mathJSExpression);

                    let derivative = math.derivative(expr, variable);
                    try {
                        derivative = math.simplify(derivative);
                        try {
                            derivative = math.rationalize(derivative, { exactFractions: false });
                        } catch (e) {
                            try {
                                derivative = math.rationalize(derivative);
                            } catch (e) {
                            }
                        }
                    } catch (e) {
                        console.warn('Simplification failed:', e);
                    }

                    const derivativeLatexRaw = derivative.toTex();
                    const derivativeLatex = derivativeLatexRaw
                        .replace(/\\mathrm\{([^}]+)\}/g, "$1")
                        .replace(/~/g, "");

                    const newFuncName = `${funcName}'`;

                    const derivativeField = new TextField(
                        textField.x + 50,
                        textField.y + 50,
                        `${newFuncName}(${variable}) = ${derivativeLatex}`,
                        true
                    );

                    this.currentNote.textFields.push(derivativeField);
                    this.createTextField(
                        derivativeField.x,
                        derivativeField.y,
                        derivativeField.content,
                        true,
                        derivativeField.id
                    );

                    this.currentNote.lastEdited = Date.now();
                    this.saveNotes();

                } catch (error) {
                    alert(`Error calculating derivative: ${error.message}`);
                }
            }

            toggleSidebar() {
                this.sidebar.classList.toggle('open');
                this.sidebarToggle.classList.toggle('open');
                this.mainContent.classList.toggle('sidebar-open');

                const icon = this.sidebarToggle.querySelector('.material-icons');
                const isOpen = this.sidebar.classList.contains('open');
                icon.textContent = isOpen ? 'close' : 'menu';

                localStorage.setItem('zeronote-sidebarState', isOpen ? 'open' : 'closed');
            }

            getMousePosition(e) {
                const rect = this.backgroundCanvas.getBoundingClientRect();
                const scale = this.scale;
                const x = (e.clientX - rect.left - this.canvasOffset.x) / scale;
                const y = (e.clientY - rect.top - this.canvasOffset.y) / scale;
                return { x, y };
            }

            getDrawingAtPosition(pos) {
                if (!this.currentNote) return null;

                const padding = 5 / this.scale;

                for (let i = this.currentNote.drawings.length - 1; i >= 0; i--) {
                    const drawing = this.currentNote.drawings[i];
                    const bounds = this.calculateBounds(drawing.path);

                    if (pos.x >= bounds.minX - padding && pos.x <= bounds.maxX + padding &&
                        pos.y >= bounds.minY - padding && pos.y <= bounds.maxY + padding) {

                        if (this.isPointNearPath(pos, drawing.path, 8 / this.scale)) {
                            return drawing;
                        }
                    }
                }
                return null;
            }

            isPointNearPath(point, path, tolerance) {
                for (let i = 0; i < path.length - 1; i++) {
                    const p1 = path[i];
                    const p2 = path[i + 1];
                    if (this.distanceToSegment(point, p1, p2) <= tolerance) {
                        return true;
                    }
                }
                return false;
            }

            distanceToSegment(p, p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const l2 = dx * dx + dy * dy;
                if (l2 === 0) return Math.hypot(p.x - p1.x);

                const t = Math.max(0, Math.min(1, ((p.x - p1.x) * dx + (p.y - p1.y) * dy) / l2));
                const proj = { x: p1.x + t * dx, y: p1.y + t * dy };
                return Math.hypot(p.x - proj.x, p.y - proj.y);
            }

            setupEventListeners() {
                this.sidebarToggle.addEventListener('click', () => this.toggleSidebar());
                this.newNoteButton.addEventListener('click', () => this.createNote());
                this.mathModeButton.addEventListener('click', () => this.toggleMathMode());
                this.drawingModeButton.addEventListener('click', () => this.toggleDrawingMode());
                this.canvasContainer.addEventListener('click', (e) => this.handleCanvasClick(e));

                window.addEventListener('resize', () => this.resizeCanvas());
                window.addEventListener('keydown', (e) => this.handleKeyboard(e));
                const deleteButtons = this.deleteModal.querySelectorAll('.modal-button');
                deleteButtons.forEach(button => {
                    if (button.classList.contains('delete')) {
                        this.deleteButton = button;
                    }
                    button.addEventListener('click', () => {
                        if (button.classList.contains('delete')) {
                            this.deleteCurrentNote();
                        }
                        this.deleteModal.classList.remove('open');
                    });
                });

                this.textFieldsLayer.addEventListener('mousedown', (e) => {
                    const field = e.target.closest('.text-field');
                    if (field) {
                        this.clearSelections();
                        const fieldId = field.dataset.id;
                        const textField = this.currentNote.textFields.find(f => f.id === fieldId);
                        if (textField) {
                            field.classList.add('selected');
                            this.selectedFields.add(fieldId);

                            this.removeEmptyTextFields();
                        }
                    }
                }, true);

                this.canvasContainer.addEventListener('mousedown', (e) => {
                    if (this.activeMode !== 'drawing' && !e.target.closest('.text-field') && e.button == 0) {
                        const pos = this.getMousePosition(e);
                        const drawing = this.getDrawingAtPosition(pos);

                        if (drawing) {
                            e.stopPropagation();
                            this.removeEmptyTextFields();
                            this.clearSelections();
                            this.selectedDrawings.add(drawing.id);
                            this.redrawCanvas();
                            this.startDrawingDrag(e);
                        } else {
                            if (!e.target.closest('.text-field') && !e.target.closest('.image-field')) {
                                this.clearSelections();
                                this.redrawCanvas();
                            }
                            this.startPanning(e);
                        }
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    this.pan(e);
                });

                document.addEventListener('mouseup', (e) => {
                    this.stopPanning(e);
                });

                document.addEventListener('mouseup', (e) => {
                    this.stopDraggingDrawing(e);
                });

                this.canvasContainer.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        const touch = e.touches[0];
                        this.startPanning({
                            button: 0,
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                            target: touch.target,
                            pointerType: 'touch'
                        });
                    }
                });

                this.canvasContainer.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1) {
                        const touch = e.touches[0];
                        this.pan({
                            clientX: touch.clientX,
                            clientY: touch.clientY
                        });
                    }
                });

                this.canvasContainer.addEventListener('touchend', () => {
                    this.stopPanning({});
                });
            }

            setupInteract() {
                interact('.text-field').styleCursor(false);
            }

            setupDrawing() {
                const dpr = window.devicePixelRatio || 1;
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(dpr, dpr);
                this.ctx.translate(this.canvasOffset.x, this.canvasOffset.y);
                this.ctx.scale(this.scale, this.scale);

                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 5 / (this.scale * (window.devicePixelRatio || 1));
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                const handlePointerStart = (e) => {
                    if (e.pointerType === 'pen' || (this.activeMode === 'drawing' && e.isPrimary)) {
                        e.preventDefault();
                        e.stopPropagation();
                        this.startDrawing(e);
                        if (e.pointerType === 'pen') {
                            this.isStylusDrawing = true;
                        }
                    }
                };

                const handlePointerMove = (e) => {
                    if ((this.isDrawing && this.activeMode === 'drawing' && e.isPrimary) ||
                        (this.isStylusDrawing && e.pointerType === 'pen')) {
                        e.preventDefault();
                        e.stopPropagation();
                        this.draw(e);
                    }
                };

                const handlePointerEnd = (e) => {
                    if (this.isDrawing && (e.isPrimary || e.pointerType === 'pen')) {
                        this.stopDrawing();
                        if (e.pointerType === 'pen') {
                            this.isStylusDrawing = false;
                        }
                    }
                };

                this.backgroundCanvas.addEventListener('pointerdown', handlePointerStart, { capture: true });
                this.backgroundCanvas.addEventListener('pointermove', handlePointerMove, { capture: true });
                this.backgroundCanvas.addEventListener('pointerup', handlePointerEnd, { capture: true });
                this.backgroundCanvas.addEventListener('pointercancel', handlePointerEnd, { capture: true });
                this.backgroundCanvas.addEventListener('pointerleave', handlePointerEnd, { capture: true });
            }

            startDrawingDrag(e) {
                if (!this.selectedDrawings.size) return;

                const clientX = e.clientX ?? e.touches[0].clientX;
                const clientY = e.clientY ?? e.touches[0].clientY;

                if (e.preventDefault) {
                    e.preventDefault();
                }

                this.isDraggingDrawing = true;
                this.lastDragPosition = { x: clientX, y: clientY };
                this.dragStartPositions.clear();

                this.selectedDrawings.forEach(id => {
                    const drawing = this.currentNote.drawings.find(d => d.id === id);
                    if (drawing) {
                        this.dragStartPositions.set(id, {
                            path: drawing.path.map(p => ({ ...p })),
                            offsetX: 0,
                            offsetY: 0
                        });
                    }
                });
            }

            stopDraggingDrawing() {
                if (!this.isDraggingDrawing) return;

                this.isDraggingDrawing = false;
                this.pushToUndo();
                this.saveNotes();
                this.dragStartPositions.clear();
            }

            startDrawing(e) {
                if (e.pointerType === 'mouse' && e.button !== 0) return;

                if (!this.currentNote) {
                    this.currentNote = this.createNote();
                }

                this.removeEmptyTextFields();
                this.clearSelections();

                this.pushToUndo();
                this.isDrawing = true;
                const pos = this.getMousePosition(e);

                // Reset the transform state
                const dpr = window.devicePixelRatio || 1;
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(dpr, dpr);
                this.ctx.translate(this.canvasOffset.x, this.canvasOffset.y);
                this.ctx.scale(this.scale, this.scale);

                // Set up drawing style
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 5 / (this.scale * (window.devicePixelRatio || 1));
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                this.ctx.beginPath();
                this.ctx.moveTo(pos.x, pos.y);

                this.currentPath = [pos];
            }

            stopDrawing() {
                if (!this.isDrawing) return;

                this.isDrawing = false;
                if (this.currentPath && this.currentPath.length > 1) {
                    this.pushToUndo();
                    const drawing = {
                        id: crypto.randomUUID(),
                        path: this.currentPath,
                        bounds: this.calculateBounds(this.currentPath)
                    };
                    this.currentNote.drawings.push(drawing);
                    this.currentNote.lastEdited = Date.now();
                    this.saveNotes();
                }
                this.currentPath = null;
            }

            calculateBounds(path) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const point of path) {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                }
                return { minX, minY, maxX, maxY };
            }

            draw(e) {
                if (!this.isDrawing) return;

                const pos = this.getMousePosition(e);

                this.ctx.save();

                const dpr = window.devicePixelRatio || 1;
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(dpr, dpr);
                this.ctx.translate(this.canvasOffset.x, this.canvasOffset.y);
                this.ctx.scale(this.scale, this.scale);

                this.ctx.lineTo(pos.x, pos.y);
                this.ctx.stroke();

                this.ctx.restore();

                this.currentPath.push(pos);
            }

            redrawCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvasContainer.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;

                this.backgroundCanvas.width = width * dpr;
                this.backgroundCanvas.height = height * dpr;
                this.backgroundCanvas.style.width = `${width}px`;
                this.backgroundCanvas.style.height = `${height}px`;

                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(dpr, dpr);

                this.ctx.clearRect(0, 0, width, height);

                this.ctx.translate(this.canvasOffset.x, this.canvasOffset.y);
                this.ctx.scale(this.scale, this.scale);

                this.drawDotPattern();

                this.ctx.lineWidth = 5 / this.scale;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                this.currentNote?.drawings?.forEach(drawing => {
                    this.ctx.strokeStyle = this.selectedDrawings.has(drawing.id) ? '#4a9eff' : '#ffffff';
                    this.ctx.beginPath();
                    drawing.path.forEach((point, index) => {
                        if (index === 0) this.ctx.moveTo(point.x, point.y);
                        else this.ctx.lineTo(point.x, point.y);
                    });
                    this.ctx.stroke();
                });
            }

            resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const container = this.canvasContainer;
                const width = container.clientWidth;
                const height = container.clientHeight;

                this.backgroundCanvas.width = width * dpr;
                this.backgroundCanvas.height = height * dpr;

                this.backgroundCanvas.style.width = `${width}px`;
                this.backgroundCanvas.style.height = `${height}px`;

                this.ctx.scale(dpr, dpr);
                this.redrawCanvas();
            }

            createNote() {
                const note = new Note();
                this.notes.unshift(note);
                this.saveNotes();
                this.renderNotesList();
                this.loadNote(note.id);
                return note;
            }

            loadNotes() {
                const savedNotes = localStorage.getItem('zeronote-notes');
                if (savedNotes) {
                    const parsedNotes = JSON.parse(savedNotes);

                    this.notes = parsedNotes.map(noteData => {
                        const note = new Note(noteData.id, noteData.title);
                        note.textFields = noteData.textFields.map(fieldData =>
                            new TextField(
                                fieldData.x,
                                fieldData.y,
                                fieldData.content,
                                fieldData.isMath,
                                fieldData.id,
                                fieldData.width
                            )
                        );
                        note.imageFields = noteData.imageFields.map(imgData =>
                            new ImageField(imgData.x, imgData.y, imgData.dataUrl, imgData.width, imgData.height)
                        );
                        note.drawings = noteData.drawings || [];
                        note.lastEdited = noteData.lastEdited;
                        return note;
                    });

                    if (this.notes.length > 0) {
                        Note.lastId = Math.max(...this.notes.map(note => note.id));
                    }

                    this.renderNotesList();
                    if (this.notes.length > 0) {
                        this.loadNote(this.notes[0].id);
                    }
                }
            }

            saveNotes() {
                const notesToSave = this.notes.map(note => ({
                    ...note,
                    textFields: note.textFields.map(field => ({
                        id: field.id,
                        x: field.x,
                        y: field.y,
                        content: field.content,
                        isMath: field.isMath,
                        width: field.width
                    })),
                    imageFields: note.imageFields.map(field => ({
                        id: field.id,
                        x: field.x,
                        y: field.y,
                        dataUrl: field.dataUrl,
                        width: field.width,
                        height: field.height
                    }))
                }));

                localStorage.setItem('zeronote-notes', JSON.stringify(notesToSave));
                this.renderNotesList();
            }

            renderNotesList() {
                this.notesList.innerHTML = '';
                this.notes
                    .sort((a, b) => b.lastEdited - a.lastEdited)
                    .forEach(note => {
                        const noteElement = document.createElement('div');
                        noteElement.className = 'note-item';
                        if (this.currentNote && this.currentNote.id === note.id) {
                            noteElement.classList.add('active-note');
                        }
                        noteElement.setAttribute('data-note-id', note.id);
                        noteElement.innerHTML = `
                            <div class="note-title" contenteditable="true" spellcheck="false">${note.title}</div>
                            <div class="note-date">${this.formatDate(note.lastEdited)}</div>
                            <button class="note-delete">
                                <span class="material-icons">delete</span>
                            </button>
                        `;

                        const deleteButton = noteElement.querySelector('.note-delete');
                        deleteButton.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (this.currentNote?.id === note.id) {
                                this.deleteModal.classList.add('open');
                                this.deleteButton.focus();
                            } else {
                                this.deleteNote(note.id);
                            }
                        });

                        const titleElement = noteElement.querySelector('.note-title');
                        let isEditing = false;

                        titleElement.addEventListener('click', (e) => {
                            e.stopPropagation();
                        });

                        titleElement.addEventListener('focus', (e) => {
                            e.stopPropagation();
                            isEditing = true;
                        });

                        titleElement.addEventListener('blur', () => {
                            if (isEditing) {
                                const newTitle = titleElement.textContent.trim();
                                titleElement.textContent = newTitle;
                                if (newTitle && newTitle !== note.title) {
                                    note.title = newTitle;
                                    note.lastEdited = Date.now();
                                    this.saveNotes();
                                } else if (!newTitle) {
                                    titleElement.textContent = note.title;
                                }
                                isEditing = false;
                            }
                        });

                        titleElement.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                titleElement.blur();
                            }
                        });

                        noteElement.addEventListener('click', (e) => {
                            if (!isEditing && (!this.currentNote || this.currentNote.id !== note.id)) {
                                this.loadNote(note.id);
                            }
                        });

                        this.notesList.appendChild(noteElement);
                    });
            }

            formatDate(timestamp) {
                const date = new Date(timestamp);
                return `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')}.${date.getFullYear().toString().slice(2)} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
            }

            loadNote(noteId, noteElement) {
                const previousNote = this.currentNote;
                this.currentNote = this.notes.find(note => note.id === noteId);
                if (!this.currentNote) return;

                if (previousNote && previousNote.id === this.currentNote.id) return;

                const currentNoteElement = document.querySelector(`.note-item[data-note-id="${noteId}"]`);

                this.textFieldsLayer.innerHTML = '';

                this.currentNote.textFields.forEach(field => {
                    this.createTextField(field.x, field.y, field.content, field.isMath, field.id);
                });

                this.currentNote.imageFields = this.currentNote.imageFields || [];
                this.currentNote.imageFields.forEach(field => {
                    this.createImageField(field);
                });

                this.removeEmptyTextFields();
                this.redrawCanvas();
                this.renderNotesList();
            }

            deleteNote(noteId) {
                const index = this.notes.findIndex(note => note.id === noteId);
                if (index !== -1) {
                    this.notes.splice(index, 1);
                    this.saveNotes();
                    if (this.notes.length > 0) {
                        this.loadNote(this.notes[0].id);
                    } else {
                        this.currentNote = null;
                        this.textFieldsLayer.innerHTML = '';
                        this.redrawCanvas();
                    }
                }
            }

            deleteCurrentNote() {
                if (this.currentNote) {
                    this.deleteNote(this.currentNote.id);
                }
            }

            toggleMathMode() {
                if (this.selectedFields.size === 1) {
                    const fieldId = Array.from(this.selectedFields)[0];
                    const element = this.textFieldsLayer.querySelector(`[data-id="${fieldId}"]`);
                    const textField = this.currentNote.textFields.find(f => f.id === fieldId);

                    if (element && textField) {
                        textField.isMath = !textField.isMath;
                        const content = textField.content;
                        const position = {
                            x: parseFloat(element.getAttribute('data-x')),
                            y: parseFloat(element.getAttribute('data-y'))
                        };

                        element.remove();

                        const newField = this.createTextField(
                            position.x,
                            position.y,
                            content,
                            textField.isMath,
                            fieldId
                        );

                        if (textField.isMath) {
                            const mathTextarea = newField.querySelector("textarea[name='MathInput']");
                            mathTextarea?.focus();
                        } else {
                            newField.focus();
                        }

                        this.saveNotes();
                    }
                } else {
                    this.mathModeActive = !this.mathModeActive;
                    this.mathModeButton.classList.toggle('active');
                }
            }

            toggleDrawingMode() {
                this.activeMode = this.activeMode === 'drawing' ? 'text' : 'drawing';
                this.drawingModeButton.classList.toggle('active');
                this.mathModeButton.classList.remove('active');
                this.backgroundCanvas.style.pointerEvents = this.activeMode === 'drawing' ? 'auto' : 'none';

                this.clearSelections();

                if (this.activeMode === 'drawing') {
                    this.canvasContainer.style.cursor = 'crosshair';
                    this.isPanning = false;
                    this.canvasContainer.classList.remove('grabbing');
                } else {
                    this.canvasContainer.style.cursor = 'grab';
                }
            }

            handleCanvasClick(e) {
                if (this.activeMode === 'drawing') return;

                if (this.justCreatedTextField) {
                    this.justCreatedTextField = false;
                    return;
                }

                const pos = this.getMousePosition(e);
                const drawing = this.getDrawingAtPosition(pos);

                if (!e.target.closest('.text-field') && !e.target.closest('.image-field') && !drawing) {
                    this.clearSelections();
                    this.redrawCanvas();
                }
            }

            clearSelections() {
                this.selectedFields.clear();
                this.selectedDrawings.clear();
                document.querySelectorAll('.text-field, .image-field').forEach(f => f.classList.remove('selected'));
            }

            createTextField(x, y, content = '', isMath = false, id = null) {
                this.textFieldsLayer.querySelectorAll('.text-field').forEach(field => {
                    if (!field.textContent.trim()) {
                        const fieldId = field.getAttribute('data-id');
                        const index = this.currentNote.textFields.findIndex(f => f.id === fieldId);
                        if (index !== -1) {
                            this.currentNote.textFields.splice(index, 1);
                        }
                        field.remove();
                    }
                });

                const textFieldsCount = this.currentNote.textFields.filter(f => !f.isMath).length;
                const mathFieldsCount = this.currentNote.textFields.filter(f => f.isMath).length;

                const field = document.createElement('div');
                field.className = 'text-field';
                field.setAttribute('data-id', id || crypto.randomUUID());
                field.style.transform = `translate(${x * this.scale + this.canvasOffset.x}px, ${y * this.scale + this.canvasOffset.y}px)`;
                field.setAttribute('data-x', x);
                field.setAttribute('data-y', y);
                field.setAttribute('data-ph', 'Type here...');

                const textField = this.currentNote.textFields.find(f => f.id === id) ||
                    new TextField(x, y, content, isMath, id);

                if (!this.currentNote.textFields.some(f => f.id === textField.id)) {
                    this.currentNote.textFields.push(textField);
                }

                if (isMath) {
                    const mqField = document.createElement('div');
                    field.appendChild(mqField);
                    const mathField = MQ.MathField(mqField, {
                        spaceBehavesLikeTab: true,
                        substituteTextarea: () => {
                            const textarea = document.createElement('textarea');
                            textarea.setAttribute('name', 'MathInput');
                            return textarea;
                        },
                        handlers: {
                            edit: () => {
                                const latex = mathField.latex();
                                textField.content = latex;
                                if (!latex.trim()) {
                                    const index = this.currentNote.textFields.findIndex(f => f.id === textField.id);
                                    if (index !== -1) {
                                        this.currentNote.textFields.splice(index, 1);
                                        field.remove();
                                    }
                                }
                                this.currentNote.lastEdited = Date.now();
                                this.saveNotes();
                            }
                        }
                    });

                    if (content) {
                        mathField.latex(content);
                    }

                    textField.mathField = mathField;
                    field.classList.add('math-field');

                    field.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        this.showContextMenu(e.clientX, e.clientY, field);
                    });
                }

                field.style.fontSize = `${2 * this.scale}rem`;
                const remBase = parseFloat(getComputedStyle(document.documentElement).fontSize);
                field.style.padding = `${(0.5 * remBase * this.scale) / remBase}rem`;

                if (!isMath) {

                    field.contentEditable = true;
                    field.spellcheck = false;
                    field.textContent = content;

                    if (textField.width) {
                        field.style.width = `${textField.width}px`;
                    }
                }

                field.addEventListener('copy', (e) => {
                    const selection = window.getSelection();
                    if (!selection.isCollapsed) return;

                    e.preventDefault();
                    e.clipboardData.setData('text/plain', field.textContent);
                });

                field.addEventListener('input', () => {
                    if (!isMath) {
                        textField.content = field.textContent;

                        const leftHandle = document.createElement('div');
                        leftHandle.className = 'resize-handle left';
                        field.appendChild(leftHandle);

                        const rightHandle = document.createElement('div');
                        rightHandle.className = 'resize-handle right';
                        field.appendChild(rightHandle);

                        leftHandle.addEventListener('dblclick', () => this.autoResizeTextField(field, textField));
                        rightHandle.addEventListener('dblclick', () => this.autoResizeTextField(field, textField));


                        if (!field.textContent.trim()) {
                            field.textContent = '';
                            field.classList.add('empty');
                        } else {
                            field.classList.remove('empty');
                        }
                        this.currentNote.lastEdited = Date.now();
                        this.saveNotes();
                    }
                });

                field.addEventListener('blur', () => {
                    if (!isMath && !field.textContent.trim()) {
                        field.classList.add('empty');
                    }
                });

                field.addEventListener('focus', () => {
                    field.classList.remove('empty');
                    this.mathModeButton.disabled = false;
                    this.mathModeButton.style.opacity = '1';
                });

                field.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('resize-handle')) {
                        return;
                    }

                    this.clearSelections();
                    field.classList.add('selected');
                    this.selectedFields.add(textField.id);

                    const leftHandle = document.createElement('div');
                    leftHandle.className = 'resize-handle left';
                    field.appendChild(leftHandle);

                    const rightHandle = document.createElement('div');
                    rightHandle.className = 'resize-handle right';
                    field.appendChild(rightHandle);

                    leftHandle.addEventListener('dblclick', () => this.autoResizeTextField(field, textField));
                    rightHandle.addEventListener('dblclick', () => this.autoResizeTextField(field, textField));

                    if (window.getSelection().toString()) {
                        return;
                    }
                });

                this.setupTextFieldInteractions(field, textField);

                this.textFieldsLayer.appendChild(field);
                return field;
            }

            autoResizeTextField(field, textField) {
                const temp = document.createElement('div');
                temp.style.cssText = window.getComputedStyle(field).cssText;
                temp.style.position = 'absolute';
                temp.style.visibility = 'hidden';
                temp.style.width = 'auto';
                temp.style.whiteSpace = 'pre-wrap';
                temp.style.maxWidth = '1500px';
                temp.textContent = field.textContent;
                document.body.appendChild(temp);

                const width = Math.min(1500, temp.offsetWidth + 20);
                field.style.width = `${width}px`;
                textField.width = width;
                this.saveNotes();

                document.body.removeChild(temp);
            }

            setupTextFieldInteractions(field, textField) {
                let initialMousePos = { x: 0, y: 0 };
                let initialFieldPos = { x: 0, y: 0 };

                interact(field)
                    .draggable({
                        inertia: false,
                        modifiers: [],
                        listeners: {
                            start: (event) => {
                                if (!field.textContent.trim()) {
                                    const fieldId = field.getAttribute('data-id');
                                    const index = this.currentNote.textFields.findIndex(f => f.id === fieldId);
                                    if (index !== -1) {
                                        this.currentNote.textFields.splice(index, 1);
                                    }
                                    field.remove();
                                    event.interaction.stop();
                                    return;
                                }

                                if (event.target.closest('.mq-editable-field')) {
                                    event.interaction.stop();
                                    return;
                                }

                                this.pushToUndo();
                                initialMousePos = {
                                    x: event.clientX,
                                    y: event.clientY
                                };
                                initialFieldPos = {
                                    x: parseFloat(field.getAttribute('data-x')) || 0,
                                    y: parseFloat(field.getAttribute('data-y')) || 0
                                };

                                this.clearSelections();
                                field.classList.add('selected');
                                this.selectedFields.add(textField.id);
                            },
                            move: (event) => {
                                const deltaX = (event.clientX - initialMousePos.x) / this.scale;
                                const deltaY = (event.clientY - initialMousePos.y) / this.scale;

                                const newX = initialFieldPos.x + deltaX;
                                const newY = initialFieldPos.y + deltaY;

                                const screenX = newX * this.scale + this.canvasOffset.x;
                                const screenY = newY * this.scale + this.canvasOffset.y;

                                field.style.transform = `translate(${screenX}px, ${screenY}px)`;
                                field.setAttribute('data-x', newX);
                                field.setAttribute('data-y', newY);

                                textField.x = newX;
                                textField.y = newY;
                            },
                            end: () => {
                                this.currentNote.lastEdited = Date.now();
                                this.saveNotes();
                            }
                        }
                    });

                if (!textField.isMath) {
                    interact(field)
                        .resizable({
                            edges: { left: '.resize-handle.left', right: '.resize-handle.right' },
                            modifiers: [
                                interact.modifiers.restrictSize({
                                    min: { width: 20 },
                                    max: { width: 1500 }
                                })
                            ],
                            inertia: false,
                            listeners: {
                                start: event => {
                                    event.stopPropagation();
                                    this.pushToUndo();
                                },
                                move: event => {
                                    const target = event.target;
                                    let width = event.rect.width;

                                    if (event.edges.left) {
                                        const deltaX = event.deltaRect.left / this.scale;
                                        const newX = parseFloat(target.getAttribute('data-x')) + deltaX;
                                        target.setAttribute('data-x', newX);
                                        const screenX = newX * this.scale + this.canvasOffset.x;
                                        target.style.transform = `translate(${screenX}px, ${target.getAttribute('data-y') * this.scale + this.canvasOffset.y}px)`;
                                        textField.x = newX;
                                    }

                                    target.style.width = `${width}px`;
                                    textField.width = width;
                                },
                                end: () => {
                                    this.currentNote.lastEdited = Date.now();
                                    this.saveNotes();
                                }
                            }
                        });
                }
            }

            focusAndSelectTextField(element, fieldId) {
                element.focus();
                this.clearSelections();
                element.classList.add('selected');
                this.selectedFields.add(fieldId);

                const range = document.createRange();
                range.selectNodeContents(element);
                range.collapse(false);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                this.mathModeButton.disabled = false;
                this.mathModeButton.style.opacity = '1';
            }

            removeEmptyTextFields() {
                let removedAny = false;
                const emptyFields = Array.from(this.textFieldsLayer.querySelectorAll('.text-field')).filter(field => {
                    return !field.textContent.trim();
                });

                emptyFields.forEach(field => {
                    const fieldId = field.getAttribute('data-id');
                    const index = this.currentNote.textFields.findIndex(f => f.id === fieldId);
                    if (index !== -1) {
                        this.currentNote.textFields.splice(index, 1);
                        field.remove();
                        removedAny = true;
                    }
                });

                return removedAny;
            }

            updateCanvasTransform() {
                this.ctx.lineWidth = 5 / this.scale;

                this.redrawCanvas();

                this.textFieldsLayer.querySelectorAll('.text-field, .image-field').forEach(element => {
                    const virtualX = parseFloat(element.dataset.x);
                    const virtualY = parseFloat(element.dataset.y);
                    const screenX = virtualX * this.scale + this.canvasOffset.x;
                    const screenY = virtualY * this.scale + this.canvasOffset.y;

                    if (element.classList.contains('image-field')) {
                        const img = element.querySelector('img');
                        const field = this.currentNote.imageFields.find(f => f.id === element.dataset.id);
                        if (field) {
                            img.style.width = `${field.width * this.scale}px`;
                            img.style.height = `${field.height * this.scale}px`;
                        }
                    } else if (element.classList.contains('text-field')) {
                        element.style.fontSize = `${2 * this.scale}rem`;
                        const remBase = parseFloat(getComputedStyle(document.documentElement).fontSize);
                        element.style.padding = `${(0.5 * remBase * this.scale) / remBase}rem`;

                        if (element.classList.contains('math-field')) {
                            const remBase = parseFloat(getComputedStyle(document.documentElement).fontSize);
                            element.style.padding = `${(0.5 * remBase * this.scale) / remBase}rem`;
                        }
                    }

                    element.style.transform = `translate(${screenX}px, ${screenY}px)`;
                });
            }

            handleKeyboard(e) {
                if (e.key === 'Delete') {
                    e.preventDefault();
                    this.deleteSelected();
                }
                else if (e.ctrlKey) {
                    if (e.key === 'z') {
                        e.preventDefault();
                        this.undo();
                    } else if (e.key === 'y') {
                        e.preventDefault();
                        this.redo();
                    }
                }
            }

            deleteSelected() {
                if (!this.currentNote) return;

                let shouldPushUndo = false;
                const originalState = JSON.parse(JSON.stringify(this.currentNote));

                document.querySelectorAll('.selected').forEach(element => {
                    const fieldId = element.dataset.id;
                    if (fieldId) {
                        this.selectedFields.add(fieldId);
                    }
                });

                this.selectedFields.forEach(id => {
                    const element = this.textFieldsLayer.querySelector(`[data-id="${id}"]`);
                    if (element) {
                        shouldPushUndo = true;
                        element.remove();
                        this.saveNotes();

                        const textFieldIndex = this.currentNote.textFields.findIndex(f => f.id === id);
                        if (textFieldIndex !== -1) {
                            this.currentNote.textFields.splice(textFieldIndex, 1);
                        }

                        const imageFieldIndex = this.currentNote.imageFields.findIndex(f => f.id === id);
                        if (imageFieldIndex !== -1) {
                            this.currentNote.imageFields.splice(imageFieldIndex, 1);
                        }
                    }
                });

                this.selectedDrawings.forEach(id => {
                    const drawingIndex = this.currentNote.drawings.findIndex(d => d.id === id);
                    if (drawingIndex !== -1) {
                        shouldPushUndo = true;
                        this.currentNote.drawings.splice(drawingIndex, 1);
                        this.saveNotes();
                    }
                });

                if (shouldPushUndo) {
                    this.undoStack.push(JSON.stringify(originalState));
                    this.redoStack = [];
                    this.currentNote.lastEdited = Date.now();
                    this.saveNotes();
                }

                this.clearSelections();
                this.redrawCanvas();
            }

            applyState() {
                this.textFieldsLayer.innerHTML = '';
                this.currentNote.textFields.forEach(f => {
                    this.createTextField(f.x, f.y, f.content, f.isMath, f.id);
                });
                this.currentNote.imageFields.forEach(f => {
                    this.createImageField(f);
                });
                this.updateCanvasTransform();
                this.redrawCanvas();
            }

            pushToUndo() {
                if (!this.currentNote) return;

                const state = {
                    textFields: JSON.parse(JSON.stringify(this.currentNote.textFields)),
                    drawings: JSON.parse(JSON.stringify(this.currentNote.drawings)),
                    imageFields: JSON.parse(JSON.stringify(this.currentNote.imageFields)),
                    lastEdited: Date.now()
                };

                const lastState = this.undoStack[this.undoStack.length - 1];
                if (!lastState || JSON.stringify(state) !== lastState) {
                    this.undoStack.push(JSON.stringify(state));
                    this.redoStack = [];
                }
            }

            undo() {
                if (this.undoStack.length === 0) return;

                const currentState = {
                    textFields: JSON.parse(JSON.stringify(this.currentNote.textFields)),
                    drawings: JSON.parse(JSON.stringify(this.currentNote.drawings)),
                    imageFields: JSON.parse(JSON.stringify(this.currentNote.imageFields)),
                    lastEdited: this.currentNote.lastEdited
                };
                this.redoStack.push(JSON.stringify(currentState));

                const snapshot = this.undoStack.pop();
                const state = JSON.parse(snapshot);

                this.currentNote.textFields = state.textFields.map(f =>
                    new TextField(f.x, f.y, f.content, f.isMath, f.id)
                );
                this.currentNote.imageFields = state.imageFields.map(img =>
                    new ImageField(img.x, img.y, img.dataUrl, img.width, img.height)
                );
                this.currentNote.drawings = state.drawings;
                this.currentNote.lastEdited = state.lastEdited;

                this.applyState();
                this.saveNotes();
            }

            redo() {
                if (this.redoStack.length === 0) return;

                const currentState = {
                    textFields: JSON.parse(JSON.stringify(this.currentNote.textFields)),
                    drawings: JSON.parse(JSON.stringify(this.currentNote.drawings)),
                    imageFields: JSON.parse(JSON.stringify(this.currentNote.imageFields)),
                    lastEdited: this.currentNote.lastEdited
                };
                this.undoStack.push(JSON.stringify(currentState));

                const snapshot = this.redoStack.pop();
                const state = JSON.parse(snapshot);

                this.currentNote.textFields = state.textFields.map(f =>
                    new TextField(f.x, f.y, f.content, f.isMath, f.id)
                );
                this.currentNote.imageFields = state.imageFields.map(img =>
                    new ImageField(img.x, img.y, img.dataUrl, img.width, img.height)
                );
                this.currentNote.drawings = state.drawings;
                this.currentNote.lastEdited = state.lastEdited;

                this.applyState();
                this.saveNotes();
            }

            startPanning(e) {
                if (e.pointerType === 'pen') return;
                if (e.button !== 0 || e.target.closest('.text-field') || e.target.closest('.image-field')) return;
                if (this.activeMode === 'drawing' && e.pointerType !== 'touch') return;

                this.isPanning = true;
                this.mouseDownTime = Date.now();
                this.mouseDownPosition = { x: e.clientX, y: e.clientY };
                this.lastPanPosition = { x: e.clientX, y: e.clientY };
                this.canvasContainer.classList.add('grabbing');

                setTimeout(() => {
                    if (this.isPanning) {
                        this.removeEmptyTextFields();
                        this.clearSelections();
                        this.redrawCanvas();
                    }
                }, 0);

                this.initialCanvasOffset = { ...this.canvasOffset };

                const rect = this.canvasContainer.getBoundingClientRect();
                this.clickPosition = {
                    x: (e.clientX - rect.left - this.canvasOffset.x) / this.scale,
                    y: (e.clientY - rect.top - this.canvasOffset.y) / this.scale
                };
            }

            pan(e) {
                if (!this.isPanning) return;

                const deltaX = e.clientX - this.lastPanPosition.x;
                const deltaY = e.clientY - this.lastPanPosition.y;

                this.canvasOffset.x += deltaX;
                this.canvasOffset.y += deltaY;

                this.updateCanvasTransform();

                this.lastPanPosition = { x: e.clientX, y: e.clientY };
            }

            stopPanning(e) {
                if (!this.isPanning) return;

                const moved = this.initialCanvasOffset.x !== this.canvasOffset.x ||
                    this.initialCanvasOffset.y !== this.canvasOffset.y;

                const mouseUpTime = Date.now();
                const timeDiff = mouseUpTime - this.mouseDownTime;
                const distanceX = Math.abs(e.clientX - this.mouseDownPosition.x);
                const distanceY = Math.abs(e.clientY - this.mouseDownPosition.y);

                if (!moved && timeDiff < 200 && distanceX < 5 && distanceY < 5) {
                    if (!this.currentNote) this.currentNote = this.createNote();

                    const pos = this.getMousePosition(e);
                    const textField = new TextField(pos.x, pos.y, '', this.mathModeActive);
                    this.currentNote.textFields.push(textField);
                    const domElement = this.createTextField(
                        pos.x,
                        pos.y,
                        '',
                        this.mathModeActive,
                        textField.id
                    );
                    this.focusAndSelectTextField(domElement, textField.id);

                    if (this.mathModeActive) {
                        const mathQuillField = domElement.querySelector('.mq-editable-field');
                        if (mathQuillField) {
                            setTimeout(() => {
                                const mathTextarea = mathQuillField.querySelector("textarea[name='MathInput']");
                                mathTextarea?.focus();
                            }, 0);
                        }
                    }

                    this.justCreatedTextField = true;
                    setTimeout(() => {
                        this.justCreatedTextField = false;
                    }, 0);
                    this.saveNotes();
                }

                this.isPanning = false;
                this.canvasContainer.classList.remove('grabbing');
            }

            setupImageHandlers() {
                document.addEventListener('paste', (e) => {
                    if (this.activeMode !== 'drawing') {
                        this.handleImagePaste(e);
                    }
                });

                this.canvasContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });

                this.canvasContainer.addEventListener('drop', (e) => {
                    if (this.activeMode !== 'drawing') {
                        this.handleImageDrop(e);
                    }
                });
            }

            async handleImagePaste(e) {
                const items = Array.from(e.clipboardData.items);
                const imageItem = items.find(item => item.type.startsWith('image'));

                if (imageItem) {
                    e.preventDefault();
                    const mousePos = this.getMousePosition(e);
                    await this.processImage(imageItem.getAsFile(), mousePos);
                }
            }

            async handleImageDrop(e) {
                e.preventDefault();
                const file = Array.from(e.dataTransfer.files).find(file => file.type.startsWith('image'));
                if (file) {
                    await this.processImage(file);
                }
            }

            async processImage(file, position = null) {
                if (!this.currentNote) this.currentNote = this.createNote();

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        let pos;
                        const rect = this.canvasContainer.getBoundingClientRect();
                        const centerX = (-this.canvasOffset.x + rect.width / 2) / this.scale;
                        const centerY = (-this.canvasOffset.y + rect.height / 2) / this.scale;
                        pos = { x: centerX, y: centerY };

                        let width = img.width;
                        let height = img.height;
                        const maxWidth = 500;

                        if (width > maxWidth) {
                            const ratio = maxWidth / width;
                            width = maxWidth;
                            height = height * ratio;
                        }

                        const imageField = new ImageField(pos.x - width / 2, pos.y - height / 2, e.target.result, width, height);
                        this.currentNote.imageFields = this.currentNote.imageFields || [];
                        this.currentNote.imageFields.push(imageField);
                        this.createImageField(imageField);
                        this.saveNotes();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            createImageField(imageField) {
                const container = document.createElement('div');
                container.className = 'image-field';
                container.setAttribute('data-id', imageField.id);
                container.style.transform = `translate(${imageField.x * this.scale + this.canvasOffset.x}px, ${imageField.y * this.scale + this.canvasOffset.y}px)`;
                container.setAttribute('data-x', imageField.x);
                container.setAttribute('data-y', imageField.y);

                const img = document.createElement('img');
                img.src = imageField.dataUrl;
                img.style.width = `${imageField.width}px`;
                img.style.height = `${imageField.height}px`;
                container.appendChild(img);

                const handles = ['top-left', 'top-right', 'bottom-left', 'bottom-right',
                    'left', 'right', 'top', 'bottom'];
                handles.forEach(pos => {
                    const handle = document.createElement('div');
                    handle.className = `resize-handle ${pos}`;
                    container.appendChild(handle);
                });

                this.setupImageInteractions(container);
                this.textFieldsLayer.appendChild(container);
                return container;
            }

            setupImageInteractions(container) {
                const img = container.querySelector('img');
                let aspectRatio = img.naturalWidth / img.naturalHeight;
                let initialWidth, initialHeight, initialX, initialY;
                let resizeStarted = false;
                let initialMousePos = { x: 0, y: 0 };

                interact(container)
                    .draggable({
                        inertia: false,
                        modifiers: [],
                        listeners: {
                            start: event => {
                                event.stopPropagation();
                                this.pushToUndo();
                                this.selectImage(container);

                                initialMousePos = {
                                    x: event.clientX,
                                    y: event.clientY
                                };
                                initialX = parseFloat(container.getAttribute('data-x')) || 0;
                                initialY = parseFloat(container.getAttribute('data-y')) || 0;
                            },
                            move: event => {
                                event.stopPropagation();
                                const deltaX = (event.clientX - initialMousePos.x) / this.scale;
                                const deltaY = (event.clientY - initialMousePos.y) / this.scale;

                                const newX = initialX + deltaX;
                                const newY = initialY + deltaY;

                                const screenX = newX * this.scale + this.canvasOffset.x;
                                const screenY = newY * this.scale + this.canvasOffset.y;

                                container.style.transform = `translate(${screenX}px, ${screenY}px)`;
                                container.setAttribute('data-x', newX);
                                container.setAttribute('data-y', newY);

                                const fieldId = container.getAttribute('data-id');
                                const field = this.currentNote.imageFields.find(f => f.id === fieldId);
                                if (field) {
                                    field.x = newX;
                                    field.y = newY;
                                    this.currentNote.lastEdited = Date.now();
                                }
                            },
                            end: () => {
                                this.saveNotes();
                            }
                        }
                    })
                    .resizable({
                        edges: {
                            left: '.resize-handle.left, .resize-handle.top-left, .resize-handle.bottom-left',
                            right: '.resize-handle.right, .resize-handle.top-right, .resize-handle.bottom-right',
                            bottom: '.resize-handle.bottom, .resize-handle.bottom-left, .resize-handle.bottom-right',
                            top: '.resize-handle.top, .resize-handle.top-left, .resize-handle.top-right'
                        },
                        modifiers: [
                            interact.modifiers.restrictSize({
                                min: { width: 10, height: 10 }
                            })
                        ],
                        inertia: false,
                        listeners: {
                            start: event => {
                                event.stopPropagation();
                                this.pushToUndo();
                                initialWidth = parseFloat(img.style.width);
                                initialHeight = parseFloat(img.style.height);
                                initialX = parseFloat(event.target.getAttribute('data-x')) || 0;
                                initialY = parseFloat(event.target.getAttribute('data-y')) || 0;
                                aspectRatio = img.naturalWidth / img.naturalHeight;
                                resizeStarted = true;
                                initialMousePos = {
                                    x: event.clientX,
                                    y: event.clientY
                                };
                            },
                            move: event => {
                                if (!resizeStarted) return;
                                event.stopPropagation();

                                const target = event.target;
                                const fieldId = target.getAttribute('data-id');
                                const field = this.currentNote.imageFields.find(f => f.id === fieldId);

                                const deltaX = event.clientX - initialMousePos.x;
                                const deltaY = event.clientY - initialMousePos.y;
                                const scaledDeltaX = deltaX / this.scale;
                                const scaledDeltaY = deltaY / this.scale;

                                let newWidth = initialWidth;
                                let newHeight = initialHeight;
                                let newX = initialX;
                                let newY = initialY;

                                if (event.edges.right) newWidth = initialWidth + scaledDeltaX;
                                if (event.edges.bottom) newHeight = initialHeight + scaledDeltaY;
                                if (event.edges.left) {
                                    newWidth = initialWidth - scaledDeltaX;
                                    newX = initialX + scaledDeltaX;
                                }
                                if (event.edges.top) {
                                    newHeight = initialHeight - scaledDeltaY;
                                    newY = initialY + scaledDeltaY;
                                }

                                if (event.shiftKey) {
                                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                                        newHeight = newWidth / aspectRatio;
                                        if (event.edges.top) {
                                            newY = initialY + (initialHeight - newHeight);
                                        }
                                    } else {
                                        newWidth = newHeight * aspectRatio;
                                        if (event.edges.left) {
                                            newX = initialX + (initialWidth - newWidth);
                                        }
                                    }
                                }

                                img.style.width = `${newWidth}px`;
                                img.style.height = `${newHeight}px`;

                                const screenX = newX * this.scale + this.canvasOffset.x;
                                const screenY = newY * this.scale + this.canvasOffset.y;
                                target.style.transform = `translate(${screenX}px, ${screenY}px)`;
                                target.setAttribute('data-x', newX);
                                target.setAttribute('data-y', newY);

                                if (field) {
                                    field.width = newWidth;
                                    field.height = newHeight;
                                    field.x = newX;
                                    field.y = newY;
                                    this.currentNote.lastEdited = Date.now();
                                }
                            },
                            end: () => {
                                resizeStarted = false;
                                this.saveNotes();
                            }
                        }
                    });

                container.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectImage(container);
                });

                container.addEventListener('keydown', async (e) => {
                    if (e.ctrlKey && e.key === 'c' && container.classList.contains('selected')) {
                        const img = container.querySelector('img');
                        try {
                            const response = await fetch(img.src);
                            const blob = await response.blob();
                            const item = new ClipboardItem({ 'image/png': blob });
                            await navigator.clipboard.write([item]);
                        } catch (err) {
                            console.error('Failed to copy image:', err);
                        }
                    }
                });

                container.setAttribute('tabindex', '0');
            }

            selectImage(container) {
                this.clearSelections();

                container.classList.add('selected');
                const fieldId = container.getAttribute('data-id');
                this.selectedFields.add(fieldId);
            }
        }

        const app = new ZeroNote();
    </script>
</body>

</html>
