<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>ZeroNote</title>
    <link rel="icon" href="favicon.avif" type="image/avif">
    <meta name="description" content="A simple note-taking app with text, maths and drawing capabilities.">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    <meta property="og:title" content="ZeroNote">
    <meta property="og:description" content="A simple note-taking app with text, maths and drawing capabilities.">
    <meta property="og:image" content="https://files.catbox.moe/40ucap.png">
    <meta property="og:url" content="https://nikityyy.github.io/ZeroNote/">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ZeroNote">
    <meta name="twitter:description" content="A simple note-taking app with text, maths and drawing capabilities.">
    <meta name="twitter:image" content="https://files.catbox.moe/40ucap.png">
    <meta name="twitter:url" content="https://nikityyy.github.io/ZeroNote/">
    <meta name="twitter:site" content="@itsnikity">
    <meta name="twitter:creator" content="@itsnikity">
    <style>
        :root {
            --sidebar-width: 250px;
            --sidebar-bg: #1a1a1a;
            --main-bg: #000000;
            --text-color: #ffffff;
            --button-bg: #333333;
            --button-hover: #444444;
            --border-color: #333333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--main-bg);
            color: var(--text-color);
            overflow: hidden;
            height: 100vh;
        }

        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: var(--sidebar-width);
            height: 100vh;
            background: var(--sidebar-bg);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-toggle {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: var(--button-bg);
            border: none;
            color: var(--text-color);
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease;
            z-index: 1001;
        }

        .sidebar-toggle.open {
            transform: translateX(var(--sidebar-width));
        }

        .notes-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .note-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--button-bg);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
        }

        .note-item:hover {
            background: var(--button-hover);
        }

        .note-title {
            font-weight: 500;
            margin-bottom: 0.25rem;
            outline: none;
            cursor: text;
        }

        .note-date {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .note-delete {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            opacity: 0.7;
        }

        .note-delete:hover {
            opacity: 1;
        }

        .new-note {
            margin: 1rem;
            padding: 0.75rem;
            background: var(--button-bg);
            border: none;
            color: var(--text-color);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
        }

        .new-note:hover {
            background: var(--button-hover);
        }

        .main-content {
            position: relative;
            height: 100vh;
            margin-left: 0;
            transition: margin-left 0.3s ease;
        }

        .main-content.sidebar-open {
            margin-left: var(--sidebar-width);
        }

        .top-buttons {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1001;
            display: flex;
            gap: 0.5rem;
        }

        .mode-button {
            background: var(--button-bg);
            border: none;
            color: var(--text-color);
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
        }

        .mode-button::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 2px;
            background: #4a9eff;
            transition: width 0.2s ease;
        }

        .mode-button:hover {
            background: var(--button-hover);
        }

        .mode-button.active {
            background: var(--button-hover);
            opacity: 1;
            box-shadow: 0 0 8px rgba(74, 158, 255, 0.3);
        }

        .mode-button.active::after {
            width: 80%;
        }

        .mode-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            box-shadow: none;
        }

        .mode-button:disabled::after {
            width: 0;
        }

        .drawing-layer {
            touch-action: none;
            pointer-events: auto;
        }

        .canvas-container {
            touch-action: none;
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
            cursor: crosshair;
        }

        .text-field {
            position: absolute;
            background: rgba(40, 40, 40, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
            min-width: 20px;
            min-height: 30px;
            cursor: move;
            touch-action: none;
            width: max-content;
            max-width: 500px;
            white-space: pre-wrap;
            word-break: break-word;
            z-index: 3;
            font-family: "Patrick Hand", sans-serif;
            font-size: 2rem;
            user-select: text;
        }

        .text-field * {
            user-select: text;
        }

        .mq-editable-field {
            font-size: 1.8rem !important;
            padding: 0.5rem;
            border-radius: 4px;
            min-width: 20px;
            min-height: 30px;
            cursor: text;
            font-family: "Patrick Hand", sans-serif;
        }

        .mq-cursor {
            background: white !important;
            border-color: white !important;
        }

        .mq-root-block {
            padding: 2px 5px !important;
        }

        .mq-focused {
            box-shadow: 0 0 0 2px #4a9eff;
            background: rgba(74, 158, 255, 0.1);
        }

        .text-field.selected {
            border-color: #4a9eff;
        }

        .selection-box {
            position: absolute;
            border: 1px dashed #4a9eff;
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 2;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.open {
            display: flex;
        }

        .modal-content {
            background: var(--sidebar-bg);
            padding: 2rem;
            border-radius: 8px;
            text-align: center;
        }

        .modal-buttons {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .modal-button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: var(--button-bg);
            color: var(--text-color);
        }

        .modal-button:hover {
            background: var(--button-hover);
        }

        .modal-button.delete {
            background: #ff4444;
        }

        .modal-button.delete:hover {
            background: #ff6666;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--main-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--button-bg);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--button-hover);
        }

        .image-field {
            position: absolute;
            cursor: move;
            touch-action: none;
            z-index: 3;
        }

        .image-field img {
            display: block;
            height: auto;
            pointer-events: none;
            border-radius: 5px;
        }

        .image-field.selected {
            outline: 2px solid #4a9eff;
        }

        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #4a9eff;
            border-radius: 50%;
            display: none;
        }

        .image-field.selected .resize-handle {
            display: block;
        }

        .resize-handle.top-left {
            top: -5px;
            left: -5px;
            cursor: nw-resize;
        }

        .resize-handle.top-right {
            top: -5px;
            right: -5px;
            cursor: ne-resize;
        }

        .resize-handle.bottom-left {
            bottom: -5px;
            left: -5px;
            cursor: sw-resize;
        }

        .resize-handle.bottom-right {
            bottom: -5px;
            right: -5px;
            cursor: se-resize;
        }

        .resize-handle.left {
            left: -5px;
            top: 50%;
            transform: translateY(-50%);
            cursor: w-resize;
        }

        .resize-handle.right {
            right: -5px;
            top: 50%;
            transform: translateY(-50%);
            cursor: e-resize;
        }

        .resize-handle.top {
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            cursor: n-resize;
        }

        .resize-handle.bottom {
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            cursor: s-resize;
        }
    </style>
</head>

<body oncontextmenu="return false">
    <button class="sidebar-toggle">
        <span class="material-icons">menu</span>
    </button>

    <div class="sidebar">
        <div class="sidebar-header">
            <h2>ZeroNote</h2>
        </div>
        <button class="new-note">
            <span class="material-icons">add</span>
            New Note
        </button>
        <div class="notes-list"></div>
    </div>

    <div class="main-content">
        <div class="top-buttons">
            <button class="mode-button math-mode" title="Math Mode">
                <span class="material-icons">functions</span>
            </button>
            <button class="mode-button drawing-mode" title="Drawing Mode">
                <span class="material-icons">brush</span>
            </button>
        </div>
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <div class="text-fields-layer"></div>
                <canvas class="drawing-layer"></canvas>
            </div>
        </div>
    </div>

    <div class="modal" id="deleteModal">
        <div class="modal-content">
            <p>Are you sure you want to delete this note?</p>
            <div class="modal-buttons">
                <button class="modal-button cancel">Cancel</button>
                <button class="modal-button delete">Delete</button>
            </div>
        </div>
    </div>

    <script>
        const MQ = MathQuill.getInterface(2);

        class Note {
            static lastId = 0;

            constructor(id = null, title = null) {
                this.id = id !== null ? Number(id) : ++Note.lastId;
                this.title = title || `Note ${this.id}`;
                this.textFields = [];
                this.drawings = [];
                this.imageFields = [];
                this.scale = 1;
                this.lastEdited = Date.now();
            }
        }

        class TextField {
            constructor(x, y, content = '', isMath = false, id = null) {
                this.id = id ?? crypto.randomUUID();
                this.x = x;
                this.y = y;
                this.content = content;
                this.isMath = isMath;
                this.mathField = null;
            }

            toJSON() {
                return {
                    id: this.id,
                    x: this.x,
                    y: this.y,
                    content: this.content,
                    isMath: this.isMath
                };
            }
        }

        class ImageField {
            constructor(x, y, dataUrl, width, height) {
                this.id = crypto.randomUUID();
                this.x = x;
                this.y = y;
                this.dataUrl = dataUrl;
                this.width = width;
                this.height = height;
            }
        }

        class ZeroNote {
            constructor() {
                this.notes = [];
                this.currentNote = null;
                this.activeMode = 'text';
                this.mathModeActive = false;
                this.scale = 1;
                this.selectedFields = new Set();
                this.selectedDrawings = new Set();
                this.isDrawing = false;
                this.undoStack = [];
                this.redoStack = [];
                this.canvasOffset = { x: 0, y: 0 };
                this.isPanning = false;
                this.lastPanPosition = { x: 0, y: 0 };
                this.isDraggingDrawing = false;
                this.dragStartPositions = new Map();
                this.deleteButton = null;
                this.justCreatedTextField = false;

                this.setupDOM();
                this.setupEventListeners();
                this.loadNotes();
                this.setupInteract();
                this.setupDrawing();
                this.setupImageHandlers();
            }

            setupDOM() {
                this.sidebar = document.querySelector('.sidebar');
                this.sidebarToggle = document.querySelector('.sidebar-toggle');
                this.notesList = document.querySelector('.notes-list');
                this.newNoteButton = document.querySelector('.new-note');
                this.mainContent = document.querySelector('.main-content');
                this.mathModeButton = document.querySelector('.math-mode');
                this.drawingModeButton = document.querySelector('.drawing-mode');
                this.textFieldsLayer = document.querySelector('.text-fields-layer');
                this.drawingLayer = document.querySelector('.drawing-layer');
                this.deleteModal = document.querySelector('#deleteModal');
                this.canvasContainer = document.querySelector('.canvas-container');

                this.ctx = this.drawingLayer.getContext('2d');
                this.resizeCanvas();
                this.mathModeButton.disabled = false;
                this.mathModeButton.style.opacity = '1';

                this.canvasWrapper = document.createElement('div');
                this.canvasWrapper.className = 'canvas-wrapper';

                this.canvasContainer.innerHTML = '';
                this.canvasContainer.appendChild(this.canvasWrapper);

                this.canvasWrapper.appendChild(this.textFieldsLayer);
                this.canvasWrapper.appendChild(this.drawingLayer);

                const sidebarState = localStorage.getItem('zeronote-sidebarState');
                if (sidebarState === 'open') {
                    this.sidebar.classList.add('open');
                    this.sidebarToggle.classList.add('open');
                    this.mainContent.classList.add('sidebar-open');
                }
                this.drawingModeButton.classList.remove('active');
                this.canvasContainer.style.cursor = 'grab';
            }

            toggleSidebar() {
                this.sidebar.classList.toggle('open');
                this.sidebarToggle.classList.toggle('open');
                this.mainContent.classList.toggle('sidebar-open');

                const icon = this.sidebarToggle.querySelector('.material-icons');
                const isOpen = this.sidebar.classList.contains('open');
                icon.textContent = isOpen ? 'close' : 'menu';

                if (isOpen) {
                    this.sidebarToggle.style.transform = `translateX(${this.sidebar.offsetWidth}px)`;
                } else {
                    this.sidebarToggle.style.transform = 'translateX(0)';
                }

                localStorage.setItem('zeronote-sidebarState', isOpen ? 'open' : 'closed');
            }

            getMousePosition(e) {
                const rect = this.canvasContainer.getBoundingClientRect();
                const scale = this.scale;
                const x = (e.clientX - rect.left - this.canvasOffset.x) / scale;
                const y = (e.clientY - rect.top - this.canvasOffset.y) / scale;
                return { x, y };
            }

            getDrawingAtPosition(pos) {
                if (!this.currentNote) return null;

                const padding = 5 / this.scale;

                for (let i = this.currentNote.drawings.length - 1; i >= 0; i--) {
                    const drawing = this.currentNote.drawings[i];
                    const bounds = this.calculateBounds(drawing.path);

                    if (pos.x >= bounds.minX - padding && pos.x <= bounds.maxX + padding &&
                        pos.y >= bounds.minY - padding && pos.y <= bounds.maxY + padding) {

                        if (this.isPointNearPath(pos, drawing.path, 8 / this.scale)) {
                            return drawing;
                        }
                    }
                }
                return null;
            }

            isPointNearPath(point, path, tolerance) {
                for (let i = 0; i < path.length - 1; i++) {
                    const p1 = path[i];
                    const p2 = path[i + 1];
                    if (this.distanceToSegment(point, p1, p2) <= tolerance) {
                        return true;
                    }
                }
                return false;
            }

            distanceToSegment(p, p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const l2 = dx * dx + dy * dy;
                if (l2 === 0) return Math.hypot(p.x - p1.x);

                const t = Math.max(0, Math.min(1, ((p.x - p1.x) * dx + (p.y - p1.y) * dy) / l2));
                const proj = { x: p1.x + t * dx, y: p1.y + t * dy };
                return Math.hypot(p.x - proj.x, p.y - proj.y);
            }

            setupEventListeners() {
                this.sidebarToggle.addEventListener('click', () => this.toggleSidebar());
                this.newNoteButton.addEventListener('click', () => this.createNote());
                this.mathModeButton.addEventListener('click', () => this.toggleMathMode());
                this.drawingModeButton.addEventListener('click', () => this.toggleDrawingMode());
                this.canvasContainer.addEventListener('click', (e) => this.handleCanvasClick(e));

                window.addEventListener('resize', () => this.resizeCanvas());
                window.addEventListener('keydown', (e) => this.handleKeyboard(e));
                const deleteButtons = this.deleteModal.querySelectorAll('.modal-button');
                deleteButtons.forEach(button => {
                    if (button.classList.contains('delete')) {
                        this.deleteButton = button;
                    }
                    button.addEventListener('click', () => {
                        if (button.classList.contains('delete')) {
                            this.deleteCurrentNote();
                        }
                        this.deleteModal.classList.remove('open');
                    });
                });

                this.canvasContainer.addEventListener('mousedown', (e) => {
                    if (this.activeMode !== 'drawing' && !e.target.closest('.text-field') && e.button == 0) {
                        const pos = this.getMousePosition(e);
                        const drawing = this.getDrawingAtPosition(pos);

                        if (drawing) {
                            this.removeEmptyTextFields();
                            this.clearSelections();
                            this.selectedDrawings.add(drawing.id);
                            this.redrawCanvas();
                            this.startDrawingDrag(e);
                        } else {
                            if (this.selectedDrawings.size > 0) {
                                this.startDrawingDrag(e);
                            } else {
                                this.startPanning(e);
                            }
                        }
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    this.pan(e);
                });

                document.addEventListener('mouseup', (e) => {
                    this.stopPanning(e);
                });

                document.addEventListener('mouseup', (e) => {
                    this.stopDraggingDrawing(e);
                });

                document.addEventListener('mousemove', (e) => {
                    this.dragDrawing(e);
                });
            }

            setupInteract() {
                interact('.text-field').styleCursor(false);
            }

            setupDrawing() {
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 5 / (this.scale * (window.devicePixelRatio || 1));
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                const handlePointerStart = (e) => {
                    if (this.activeMode === 'drawing' && e.isPrimary) {
                        e.preventDefault();
                        e.stopPropagation();
                        this.startDrawing(e);
                    }
                };

                const handlePointerMove = (e) => {
                    if (this.isDrawing && this.activeMode === 'drawing' && e.isPrimary) {
                        e.preventDefault();
                        e.stopPropagation();
                        this.draw(e);
                    }
                };

                const handlePointerEnd = (e) => {
                    if (this.isDrawing && e.isPrimary) {
                        this.stopDrawing();
                    }
                };

                this.drawingLayer.addEventListener('pointerdown', handlePointerStart, { capture: true });
                this.drawingLayer.addEventListener('pointermove', handlePointerMove, { capture: true });
                this.drawingLayer.addEventListener('pointerup', handlePointerEnd, { capture: true });
                this.drawingLayer.addEventListener('pointercancel', handlePointerEnd, { capture: true });
                this.drawingLayer.addEventListener('pointerleave', handlePointerEnd, { capture: true });
            }

            startDrawingDrag(e) {
                const clientX = e.clientX ?? e.touches[0].clientX;
                const clientY = e.clientY ?? e.touches[0].clientY;

                if (e.preventDefault) {
                    e.preventDefault();
                }

                this.isDraggingDrawing = true;
                this.lastDragPosition = { x: clientX, y: clientY };
                this.dragStartPositions.clear();

                this.selectedDrawings.forEach(id => {
                    const drawing = this.currentNote.drawings.find(d => d.id === id);
                    if (drawing) {
                        this.dragStartPositions.set(id, {
                            path: drawing.path.map(p => ({ ...p })),
                            offsetX: 0,
                            offsetY: 0
                        });
                    }
                });
            }

            dragDrawing(e) {
                if (!this.isDraggingDrawing) return;

                const clientX = e.clientX ?? e.touches[0].clientX;
                const clientY = e.clientY ?? e.touches[0].clientY;

                const deltaX = (clientX - this.lastDragPosition.x) / this.scale;
                const deltaY = (clientY - this.lastDragPosition.y) / this.scale;

                this.selectedDrawings.forEach(id => {
                    const drawing = this.currentNote.drawings.find(d => d.id === id);
                    if (drawing && this.dragStartPositions.has(id)) {
                        const start = this.dragStartPositions.get(id);
                        drawing.path.forEach((point, index) => {
                            point.x = start.path[index].x + deltaX;
                            point.y = start.path[index].y + deltaY;
                        });
                        drawing.bounds = this.calculateBounds(drawing.path);
                    }
                });

                this.lastDragPosition = { x: clientX, y: clientY };
                this.redrawCanvas();
            }

            stopDraggingDrawing() {
                if (!this.isDraggingDrawing) return;

                this.isDraggingDrawing = false;
                this.pushToUndo();
                this.saveNotes();
                this.dragStartPositions.clear();
            }

            startDrawing(e) {
                if (e.pointerType === 'mouse' && e.button !== 0) return;

                this.pushToUndo();
                this.isDrawing = true;
                const rect = this.canvasContainer.getBoundingClientRect();
                const x = (e.clientX - rect.left - this.canvasOffset.x) / this.scale;
                const y = (e.clientY - rect.top - this.canvasOffset.y) / this.scale;

                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.currentPath = [{ x, y }];
            }

            stopDrawing() {
                if (!this.isDrawing) return;

                this.isDrawing = false;
                if (this.currentPath && this.currentPath.length > 1) {
                    this.pushToUndo();
                    const drawing = {
                        id: crypto.randomUUID(),
                        path: this.currentPath,
                        bounds: this.calculateBounds(this.currentPath)
                    };
                    this.currentNote.drawings.push(drawing);
                    this.currentNote.lastEdited = Date.now();
                    this.saveNotes();
                }
                this.currentPath = null;
            }

            calculateBounds(path) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const point of path) {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                }
                return { minX, minY, maxX, maxY };
            }

            draw(e) {
                if (!this.isDrawing) return;

                const rect = this.canvasContainer.getBoundingClientRect();
                const x = (e.clientX - rect.left - this.canvasOffset.x) / this.scale;
                const y = (e.clientY - rect.top - this.canvasOffset.y) / this.scale;

                this.ctx.lineTo(x, y);
                this.ctx.stroke();
                this.currentPath.push({ x, y });
            }

            redrawCanvas() {
                const dpr = window.devicePixelRatio || 1;
                this.ctx.clearRect(0, 0, this.drawingLayer.width / dpr, this.drawingLayer.height / dpr);

                this.ctx.lineWidth = 5 / this.scale;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                this.currentNote?.drawings?.forEach(drawing => {
                    this.ctx.strokeStyle = this.selectedDrawings.has(drawing.id) ? '#4a9eff' : '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.moveTo(drawing.path[0].x, drawing.path[0].y);
                    for (let i = 1; i < drawing.path.length; i++) {
                        this.ctx.lineTo(drawing.path[i].x, drawing.path[i].y);
                    }
                    this.ctx.stroke();
                });
            }

            resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const container = this.canvasContainer;
                const width = container.clientWidth;
                const height = container.clientHeight;

                this.drawingLayer.width = width * dpr;
                this.drawingLayer.height = height * dpr;

                this.drawingLayer.style.width = `${width}px`;
                this.drawingLayer.style.height = `${height}px`;

                this.ctx.scale(dpr, dpr);
                this.redrawCanvas();
            }

            createNote() {
                const note = new Note();
                this.notes.unshift(note);
                this.saveNotes();
                this.renderNotesList();
                this.loadNote(note.id);
                return note;
            }

            loadNotes() {
                const savedNotes = localStorage.getItem('zeronote-notes');
                if (savedNotes) {
                    const parsedNotes = JSON.parse(savedNotes);

                    this.notes = parsedNotes.map(noteData => {
                        const note = new Note(noteData.id, noteData.title);
                        note.textFields = noteData.textFields.map(fieldData =>
                            new TextField(
                                fieldData.x,
                                fieldData.y,
                                fieldData.content,
                                fieldData.isMath,
                                fieldData.id
                            )
                        );
                        note.imageFields = noteData.imageFields.map(imgData =>
                            new ImageField(imgData.x, imgData.y, imgData.dataUrl, imgData.width, imgData.height)
                        );
                        note.drawings = noteData.drawings || [];
                        note.lastEdited = noteData.lastEdited;
                        return note;
                    });

                    if (this.notes.length > 0) {
                        Note.lastId = Math.max(...this.notes.map(note => note.id));
                    }

                    this.renderNotesList();
                    if (this.notes.length > 0) {
                        this.loadNote(this.notes[0].id);
                    }
                }
            }

            saveNotes() {
                const notesToSave = this.notes.map(note => ({
                    ...note,
                    textFields: note.textFields.map(field => ({
                        id: field.id,
                        x: field.x,
                        y: field.y,
                        content: field.content,
                        isMath: field.isMath
                    })),
                    imageFields: note.imageFields.map(field => ({
                        id: field.id,
                        x: field.x,
                        y: field.y,
                        dataUrl: field.dataUrl,
                        width: field.width,
                        height: field.height
                    }))
                }));

                localStorage.setItem('zeronote-notes', JSON.stringify(notesToSave));
                this.renderNotesList();
            }

            renderNotesList() {
                this.notesList.innerHTML = '';
                this.notes
                    .sort((a, b) => b.lastEdited - a.lastEdited)
                    .forEach(note => {
                        const noteElement = document.createElement('div');
                        noteElement.className = 'note-item';
                        noteElement.innerHTML = `
                            <div class="note-title">${note.title}</div>
                            <div class="note-date">${this.formatDate(note.lastEdited)}</div>
                            <button class="note-delete">
                                <span class="material-icons">delete</span>
                            </button>
                        `;

                        const deleteButton = noteElement.querySelector('.note-delete');
                        deleteButton.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (this.currentNote?.id === note.id) {
                                this.deleteModal.classList.add('open');
                                this.deleteButton.focus();
                            } else {
                                this.deleteNote(note.id);
                            }
                        });

                        noteElement.addEventListener('click', (e) => {
                            if (e.target.closest('.note-title')?.isContentEditable || e.target.closest('.note-delete')) {
                                return;
                            }
                            this.loadNote(note.id);
                        });

                        const titleElement = noteElement.querySelector('.note-title');
                        titleElement.addEventListener('dblclick', (e) => {
                            e.stopPropagation();
                            titleElement.contentEditable = true;
                            titleElement.focus();
                        });

                        titleElement.addEventListener('blur', () => {
                            titleElement.contentEditable = false;
                            const newTitle = titleElement.textContent.trim();
                            if (newTitle !== note.title) {
                                note.title = newTitle || `Note ${note.id}`;
                                note.lastEdited = Date.now();
                                this.saveNotes();
                            }
                        });

                        titleElement.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                titleElement.blur();
                            }
                        });

                        this.notesList.appendChild(noteElement);
                    });
            }

            formatDate(timestamp) {
                const date = new Date(timestamp);
                return `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')}.${date.getFullYear().toString().slice(2)} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
            }

            loadNote(noteId) {
                this.currentNote = this.notes.find(note => note.id === noteId);
                if (!this.currentNote) return;

                this.textFieldsLayer.innerHTML = '';
                this.currentNote.textFields.forEach(field => {
                    this.createTextField(field.x, field.y, field.content, field.isMath, field.id);
                });
                this.currentNote.imageFields = this.currentNote.imageFields || [];
                this.currentNote.imageFields.forEach(field => {
                    this.createImageField(field);
                });
                this.removeEmptyTextFields();
                this.redrawCanvas();
            }

            deleteNote(noteId) {
                const index = this.notes.findIndex(note => note.id === noteId);
                if (index !== -1) {
                    this.notes.splice(index, 1);
                    this.saveNotes();
                    if (this.notes.length > 0) {
                        this.loadNote(this.notes[0].id);
                    } else {
                        this.currentNote = null;
                        this.textFieldsLayer.innerHTML = '';
                        this.redrawCanvas();
                    }
                }
            }

            deleteCurrentNote() {
                if (this.currentNote) {
                    this.deleteNote(this.currentNote.id);
                }
            }

            toggleMathMode() {
                if (this.selectedFields.size === 1) {
                    const fieldId = Array.from(this.selectedFields)[0];
                    const element = this.textFieldsLayer.querySelector(`[data-id="${fieldId}"]`);
                    const textField = this.currentNote.textFields.find(f => f.id === fieldId);

                    if (element && textField) {
                        textField.isMath = !textField.isMath;
                        const content = textField.content;
                        const position = {
                            x: parseFloat(element.getAttribute('data-x')),
                            y: parseFloat(element.getAttribute('data-y'))
                        };

                        element.remove();

                        const newField = this.createTextField(
                            position.x,
                            position.y,
                            content,
                            textField.isMath,
                            fieldId
                        );

                        if (textField.isMath) {
                            newField.querySelector('.mq-editable-field').focus();
                        } else {
                            newField.focus();
                        }

                        this.saveNotes();
                    }
                } else {
                    this.mathModeActive = !this.mathModeActive;
                    this.mathModeButton.classList.toggle('active');
                }
            }

            toggleDrawingMode() {
                this.activeMode = this.activeMode === 'drawing' ? 'text' : 'drawing';
                this.drawingLayer.classList.toggle('active');
                this.drawingModeButton.classList.toggle('active');
                this.mathModeButton.classList.remove('active');

                this.clearSelections();

                if (this.activeMode === 'drawing') {
                    this.canvasContainer.style.cursor = 'crosshair';
                    this.isPanning = false;
                    this.canvasContainer.classList.remove('grabbing');
                } else {
                    this.canvasContainer.style.cursor = 'grab';
                }
            }

            handleCanvasClick(e) {
                if (this.activeMode === 'drawing') return;

                if (this.justCreatedTextField) {
                    this.justCreatedTextField = false;
                    return;
                }

                if (!e.target.closest('.text-field') && !e.target.closest('.image-field')) {
                    this.clearSelections();
                    this.redrawCanvas();
                }
            }

            clearSelections() {
                this.selectedFields.clear();
                this.selectedDrawings.clear();
                document.querySelectorAll('.text-field, .image-field').forEach(f => f.classList.remove('selected'));
            }

            createTextField(x, y, content = '', isMath = false, id = null) {
                this.textFieldsLayer.querySelectorAll('.text-field').forEach(field => {
                    if (!field.textContent.trim()) {
                        const fieldId = field.getAttribute('data-id');
                        const index = this.currentNote.textFields.findIndex(f => f.id === fieldId);
                        if (index !== -1) {
                            this.currentNote.textFields.splice(index, 1);
                        }
                        field.remove();
                    }
                });

                const field = document.createElement('div');
                field.className = 'text-field';
                field.setAttribute('data-id', id || crypto.randomUUID());
                field.style.transform = `translate(${x}px, ${y}px)`;
                field.setAttribute('data-x', x);
                field.setAttribute('data-y', y);

                const textField = this.currentNote.textFields.find(f => f.id === id) ||
                    new TextField(x, y, content, isMath, id);

                if (isMath) {
                    const mqField = document.createElement('div');
                    field.appendChild(mqField);
                    const mathField = MQ.MathField(mqField, {
                        spaceBehavesLikeTab: true,
                        handlers: {
                            edit: () => {
                                textField.content = mathField.latex();
                                this.currentNote.lastEdited = Date.now();
                                this.saveNotes();
                            }
                        }
                    });
                    mathField.latex(content || '');
                    textField.mathField = mathField;
                    field.classList.add('math-field');
                } else {
                    field.contentEditable = true;
                    field.spellcheck = false;
                    field.textContent = content;
                }

                field.addEventListener('input', () => {
                    if (!isMath) {
                        textField.content = field.textContent;
                        this.currentNote.lastEdited = Date.now();
                        this.saveNotes();
                    }
                });

                field.addEventListener('focus', () => {
                    this.mathModeButton.disabled = false;
                    this.mathModeButton.style.opacity = '1';
                    if (isMath && textField.mathField) {
                        textField.mathField.focus();
                    }
                });

                field.addEventListener('mousedown', (e) => {
                    field.classList.add('selected');
                    this.selectedFields.add(textField.id);

                    if (window.getSelection().toString()) {
                        return;
                    }
                });

                this.setupTextFieldInteractions(field, textField);

                this.textFieldsLayer.appendChild(field);
                return field;
            }

            setupTextFieldInteractions(field, textField) {
                let initialMousePos = { x: 0, y: 0 };
                let initialFieldPos = { x: 0, y: 0 };

                interact(field)
                    .draggable({
                        inertia: false,
                        modifiers: [],
                        listeners: {
                            start: (event) => {
                                if (event.target.closest('.mq-editable-field')) {
                                    event.interaction.stop();
                                    return;
                                }

                                this.pushToUndo();
                                initialMousePos = {
                                    x: event.clientX,
                                    y: event.clientY
                                };
                                initialFieldPos = {
                                    x: parseFloat(field.getAttribute('data-x')) || 0,
                                    y: parseFloat(field.getAttribute('data-y')) || 0
                                };

                                this.clearSelections();
                                field.classList.add('selected');
                                this.selectedFields.add(textField.id);
                            },
                            move: (event) => {
                                const deltaX = event.clientX - initialMousePos.x;
                                const deltaY = event.clientY - initialMousePos.y;

                                const newX = initialFieldPos.x + deltaX;
                                const newY = initialFieldPos.y + deltaY;

                                field.style.transform = `translate(${newX}px, ${newY}px)`;
                                field.setAttribute('data-x', newX);
                                field.setAttribute('data-y', newY);

                                textField.x = newX;
                                textField.y = newY;
                            },
                            end: () => {
                                this.currentNote.lastEdited = Date.now();
                                this.saveNotes();
                            }
                        }
                    });
            }

            focusAndSelectTextField(element, fieldId) {
                element.focus();
                this.clearSelections();
                element.classList.add('selected');
                this.selectedFields.add(fieldId);

                const range = document.createRange();
                range.selectNodeContents(element);
                range.collapse(false);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                this.mathModeButton.disabled = false;
                this.mathModeButton.style.opacity = '1';
            }

            removeEmptyTextFields() {
                let removedAny = false;
                this.textFieldsLayer.querySelectorAll('.text-field').forEach(field => {
                    if (!field.textContent.trim()) {
                        const fieldId = field.getAttribute('data-id');
                        const index = this.currentNote.textFields.findIndex(f => f.id === fieldId);
                        if (index !== -1) {
                            this.currentNote.textFields.splice(index, 1);
                        }
                        field.remove();
                        removedAny = true;
                    }
                });
                return removedAny;
            }

            updateCanvasTransform() {
                this.canvasWrapper.style.transform = `translate(${this.canvasOffset.x}px, ${this.canvasOffset.y}px)`;
            }

            handleKeyboard(e) {
                if (e.key === 'Delete') {
                    e.preventDefault();
                    this.deleteSelected();
                }
                else if (e.ctrlKey) {
                    if (e.key === 'z') {
                        e.preventDefault();
                        this.undo();
                    } else if (e.key === 'y') {
                        e.preventDefault();
                        this.redo();
                    }
                }
            }

            deleteSelected() {
                if (!this.currentNote) return;

                let shouldPushUndo = false;

                this.selectedFields.forEach(id => {
                    const textField = this.currentNote.textFields.find(f => f.id === id);
                    if (textField && textField.content.trim() !== '') {
                        shouldPushUndo = true;
                    }
                });

                this.selectedFields.forEach(id => {
                    const imageField = this.currentNote.imageFields.find(f => f.id === id);
                    if (imageField) {
                        shouldPushUndo = true;
                    }
                });

                if (this.selectedDrawings.size > 0) {
                    shouldPushUndo = true;
                }

                if (shouldPushUndo) {
                    this.pushToUndo();
                }

                this.selectedFields.forEach(id => {
                    const textFieldIndex = this.currentNote.textFields.findIndex(f => f.id === id);
                    if (textFieldIndex > -1) {
                        this.currentNote.textFields.splice(textFieldIndex, 1);
                        const textFieldElement = document.querySelector(`.text-field[data-id="${id}"]`);
                        if (textFieldElement) {
                            textFieldElement.remove();
                        }
                    }

                    const imageFieldIndex = this.currentNote.imageFields.findIndex(f => f.id === id);
                    if (imageFieldIndex > -1) {
                        this.currentNote.imageFields.splice(imageFieldIndex, 1);
                        const imageFieldElement = document.querySelector(`.image-field[data-id="${id}"]`);
                        if (imageFieldElement) {
                            imageFieldElement.remove();
                        }
                    }
                });

                this.selectedDrawings.forEach(id => {
                    const index = this.currentNote.drawings.findIndex(d => d.id === id);
                    if (index > -1) {
                        this.currentNote.drawings.splice(index, 1);
                    }
                });

                this.clearSelections();
                this.saveNotes();
                this.redrawCanvas();
            }

            applyState() {
                this.textFieldsLayer.innerHTML = '';
                this.currentNote.textFields.forEach(f => {
                    this.createTextField(f.x, f.y, f.content, f.isMath, f.id);
                });
                this.currentNote.imageFields.forEach(f => {
                    this.createImageField(f);
                });
                this.updateCanvasTransform();
                this.redrawCanvas();
            }

            pushToUndo() {
                if (!this.currentNote) return;

                const state = {
                    textFields: JSON.parse(JSON.stringify(this.currentNote.textFields)),
                    drawings: JSON.parse(JSON.stringify(this.currentNote.drawings)),
                    imageFields: JSON.parse(JSON.stringify(this.currentNote.imageFields)),
                    lastEdited: Date.now()
                };

                const lastState = this.undoStack[this.undoStack.length - 1];
                if (!lastState || JSON.stringify(state) !== lastState) {
                    this.undoStack.push(JSON.stringify(state));
                    this.redoStack = [];
                }
            }

            undo() {
                if (this.undoStack.length === 0) return;

                const currentState = {
                    textFields: JSON.parse(JSON.stringify(this.currentNote.textFields)),
                    drawings: JSON.parse(JSON.stringify(this.currentNote.drawings)),
                    imageFields: JSON.parse(JSON.stringify(this.currentNote.imageFields)),
                    lastEdited: this.currentNote.lastEdited
                };
                this.redoStack.push(JSON.stringify(currentState));

                const snapshot = this.undoStack.pop();
                const state = JSON.parse(snapshot);

                this.currentNote.textFields = state.textFields.map(f =>
                    new TextField(f.x, f.y, f.content, f.isMath, f.id)
                );
                this.currentNote.imageFields = state.imageFields.map(img =>
                    new ImageField(img.x, img.y, img.dataUrl, img.width, img.height)
                );
                this.currentNote.drawings = state.drawings;
                this.currentNote.lastEdited = state.lastEdited;

                this.applyState();
                this.saveNotes();
            }

            redo() {
                if (this.redoStack.length === 0) return;

                const currentState = {
                    textFields: JSON.parse(JSON.stringify(this.currentNote.textFields)),
                    drawings: JSON.parse(JSON.stringify(this.currentNote.drawings)),
                    imageFields: JSON.parse(JSON.stringify(this.currentNote.imageFields)),
                    lastEdited: this.currentNote.lastEdited
                };
                this.undoStack.push(JSON.stringify(currentState));

                const snapshot = this.redoStack.pop();
                const state = JSON.parse(snapshot);

                this.currentNote.textFields = state.textFields.map(f =>
                    new TextField(f.x, f.y, f.content, f.isMath, f.id)
                );
                this.currentNote.imageFields = state.imageFields.map(img =>
                    new ImageField(img.x, img.y, img.dataUrl, img.width, img.height)
                );
                this.currentNote.drawings = state.drawings;
                this.currentNote.lastEdited = state.lastEdited;

                this.applyState();
                this.saveNotes();
            }

            startPanning(e) {
                if (e.button !== 0 || e.target.closest('.text-field') || e.target.closest('.image-field')) return;

                if (this.activeMode === 'drawing') return;

                this.removeEmptyTextFields();
                this.clearSelections();

                this.isPanning = true;
                this.mouseDownTime = Date.now();
                this.mouseDownPosition = { x: e.clientX, y: e.clientY };
                this.lastPanPosition = { x: e.clientX, y: e.clientY };
                this.canvasContainer.classList.add('grabbing');

                this.initialCanvasOffset = { ...this.canvasOffset };

                const rect = this.canvasContainer.getBoundingClientRect();
                this.clickPosition = {
                    x: (e.clientX - rect.left - this.canvasOffset.x) / this.scale,
                    y: (e.clientY - rect.top - this.canvasOffset.y) / this.scale
                };
            }

            pan(e) {
                if (!this.isPanning) return;

                const deltaX = e.clientX - this.lastPanPosition.x;
                const deltaY = e.clientY - this.lastPanPosition.y;

                this.canvasOffset.x += deltaX;
                this.canvasOffset.y += deltaY;

                this.updateCanvasTransform();

                this.lastPanPosition = { x: e.clientX, y: e.clientY };
            }

            stopPanning(e) {
                if (!this.isPanning) return;

                const moved = this.initialCanvasOffset.x !== this.canvasOffset.x ||
                    this.initialCanvasOffset.y !== this.canvasOffset.y;

                const mouseUpTime = Date.now();
                const timeDiff = mouseUpTime - this.mouseDownTime;
                const distanceX = Math.abs(e.clientX - this.mouseDownPosition.x);
                const distanceY = Math.abs(e.clientY - this.mouseDownPosition.y);

                if (!moved && timeDiff < 200 && distanceX < 5 && distanceY < 5) {
                    if (!this.currentNote) this.currentNote = this.createNote();

                    const textField = new TextField(this.clickPosition.x, this.clickPosition.y, '', this.mathModeActive);
                    this.currentNote.textFields.push(textField);
                    const domElement = this.createTextField(
                        this.clickPosition.x,
                        this.clickPosition.y,
                        '',
                        this.mathModeActive,
                        textField.id
                    );
                    this.focusAndSelectTextField(domElement, textField.id);

                    if (this.mathModeActive) {
                        const mathQuillField = domElement.querySelector('.mq-editable-field');
                        if (mathQuillField) {
                            setTimeout(() => {
                                textField.mathField.focus();
                            }, 0);
                        }
                    }

                    this.justCreatedTextField = true;
                    setTimeout(() => {
                        this.justCreatedTextField = false;
                    }, 0);
                    this.saveNotes();
                }

                this.isPanning = false;
                this.canvasContainer.classList.remove('grabbing');
            }

            setupImageHandlers() {
                document.addEventListener('paste', (e) => {
                    if (this.activeMode !== 'drawing') {
                        this.handleImagePaste(e);
                    }
                });

                this.canvasContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });

                this.canvasContainer.addEventListener('drop', (e) => {
                    if (this.activeMode !== 'drawing') {
                        this.handleImageDrop(e);
                    }
                });
            }

            async handleImagePaste(e) {
                const items = Array.from(e.clipboardData.items);
                const imageItem = items.find(item => item.type.startsWith('image'));

                if (imageItem) {
                    e.preventDefault();
                    const mousePos = this.getMousePosition(e);
                    await this.processImage(imageItem.getAsFile(), mousePos);
                }
            }

            async handleImageDrop(e) {
                e.preventDefault();
                const file = Array.from(e.dataTransfer.files).find(file => file.type.startsWith('image'));
                if (file) {
                    await this.processImage(file);
                }
            }

            async processImage(file, position = null) {
                if (!this.currentNote) this.currentNote = this.createNote();

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        let pos;
                        const rect = this.canvasContainer.getBoundingClientRect();
                        const centerX = (-this.canvasOffset.x + rect.width / 2) / this.scale;
                        const centerY = (-this.canvasOffset.y + rect.height / 2) / this.scale;
                        pos = { x: centerX, y: centerY };

                        let width = img.width;
                        let height = img.height;
                        const maxWidth = 500;

                        if (width > maxWidth) {
                            const ratio = maxWidth / width;
                            width = maxWidth;
                            height = height * ratio;
                        }

                        const imageField = new ImageField(pos.x - width / 2, pos.y - height / 2, e.target.result, width, height);
                        this.currentNote.imageFields = this.currentNote.imageFields || [];
                        this.currentNote.imageFields.push(imageField);
                        this.createImageField(imageField);
                        this.saveNotes();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            createImageField(imageField) {
                const container = document.createElement('div');
                container.className = 'image-field';
                container.setAttribute('data-id', imageField.id);
                container.style.transform = `translate(${imageField.x}px, ${imageField.y}px)`;
                container.setAttribute('data-x', imageField.x);
                container.setAttribute('data-y', imageField.y);

                const img = document.createElement('img');
                img.src = imageField.dataUrl;
                img.style.width = `${imageField.width}px`;
                img.style.height = `${imageField.height}px`;
                container.appendChild(img);

                const handles = ['top-left', 'top-right', 'bottom-left', 'bottom-right',
                    'left', 'right', 'top', 'bottom'];
                handles.forEach(pos => {
                    const handle = document.createElement('div');
                    handle.className = `resize-handle ${pos}`;
                    container.appendChild(handle);
                });

                this.setupImageInteractions(container);
                this.textFieldsLayer.appendChild(container);
                return container;
            }

            setupImageInteractions(container) {
                const img = container.querySelector('img');
                let aspectRatio = img.naturalWidth / img.naturalHeight;
                let initialWidth, initialHeight, initialX, initialY;
                let resizeStarted = false;
                let currentWidth, currentHeight, currentX, currentY;

                interact(container)
                    .draggable({
                        inertia: false,
                        modifiers: [],
                        listeners: {
                            start: event => {
                                event.stopPropagation();
                                this.pushToUndo();
                                this.selectImage(container);
                            },
                            move: event => {
                                event.stopPropagation();
                                const target = event.target;
                                const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                                const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

                                target.style.transform = `translate(${x}px, ${y}px)`;
                                target.setAttribute('data-x', x);
                                target.setAttribute('data-y', y);

                                const fieldId = target.getAttribute('data-id');
                                const field = this.currentNote.imageFields.find(f => f.id === fieldId);
                                if (field) {
                                    field.x = x;
                                    field.y = y;
                                    this.currentNote.lastEdited = Date.now();
                                }
                            },
                            end: () => {
                                this.saveNotes();
                            }
                        }
                    })
                    .resizable({
                        edges: {
                            left: '.resize-handle.left, .resize-handle.top-left, .resize-handle.bottom-left',
                            right: '.resize-handle.right, .resize-handle.top-right, .resize-handle.bottom-right',
                            bottom: '.resize-handle.bottom, .resize-handle.bottom-left, .resize-handle.bottom-right',
                            top: '.resize-handle.top, .resize-handle.top-left, .resize-handle.top-right'
                        },
                        modifiers: [
                            interact.modifiers.restrictSize({
                                min: { width: 10, height: 10 }
                            })
                        ],
                        inertia: false,
                        listeners: {
                            start: event => {
                                event.stopPropagation();
                                this.pushToUndo();
                                initialWidth = parseFloat(img.style.width);
                                initialHeight = parseFloat(img.style.height);
                                initialX = parseFloat(event.target.getAttribute('data-x')) || 0;
                                initialY = parseFloat(event.target.getAttribute('data-y')) || 0;
                                currentWidth = initialWidth;
                                currentHeight = initialHeight;
                                currentX = initialX;
                                currentY = initialY;
                                aspectRatio = img.naturalWidth / img.naturalHeight;
                                resizeStarted = true;
                            },
                            move: event => {
                                if (!resizeStarted) return;
                                event.stopPropagation();

                                const target = event.target;
                                const fieldId = target.getAttribute('data-id');
                                const field = this.currentNote.imageFields.find(f => f.id === fieldId);

                                requestAnimationFrame(() => {
                                    let newWidth = event.rect.width;
                                    let newHeight = event.rect.height;
                                    let newX = initialX;
                                    let newY = initialY;

                                    currentWidth = currentWidth * 0.5 + newWidth * 0.5;
                                    currentHeight = currentHeight * 0.5 + newHeight * 0.5;

                                    if (event.edges.left) newX = initialX + (initialWidth - currentWidth);
                                    if (event.edges.top) newY = initialY + (initialHeight - currentHeight);

                                    img.style.width = `${currentWidth}px`;
                                    img.style.height = `${currentHeight}px`;
                                    target.style.transform = `translate(${newX}px, ${newY}px)`;
                                    target.setAttribute('data-x', newX);
                                    target.setAttribute('data-y', newY);

                                    if (field) {
                                        field.width = currentWidth;
                                        field.height = currentHeight;
                                        field.x = newX;
                                        field.y = newY;
                                        this.currentNote.lastEdited = Date.now();
                                    }
                                });
                            },
                            end: () => {
                                resizeStarted = false;
                                this.saveNotes();
                            }
                        }
                    });

                container.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectImage(container);
                });

                container.addEventListener('keydown', async (e) => {
                    if (e.ctrlKey && e.key === 'c' && container.classList.contains('selected')) {
                        const img = container.querySelector('img');
                        try {
                            const response = await fetch(img.src);
                            const blob = await response.blob();
                            const item = new ClipboardItem({ 'image/png': blob });
                            await navigator.clipboard.write([item]);
                        } catch (err) {
                            console.error('Failed to copy image:', err);
                        }
                    }
                });

                container.setAttribute('tabindex', '0');
            }

            selectImage(container) {
                this.clearSelections();

                container.classList.add('selected');
                const fieldId = container.getAttribute('data-id');
                this.selectedFields.add(fieldId);
            }
        }

        const app = new ZeroNote();
    </script>
</body>

</html>